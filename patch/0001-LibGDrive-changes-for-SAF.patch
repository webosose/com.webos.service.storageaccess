From e5cf7724fe0bd6c982743097b61a384b3915cc04 Mon Sep 17 00:00:00 2001
From: "mukul20.jha" <mukul20.jha@lge.com>
Date: Tue, 20 Apr 2021 10:32:18 +0530
Subject: [PATCH] LibGDrive changes for SAF

---
 Makefile                                |  18 +-
 include/common/all.hpp                  |  17 +
 include/common/logging.hpp              | 138 ++++++
 include/common/loggingv2.hpp            | 168 ++++++++
 include/common/misc.hpp                 |  84 ++++
 include/common/path.hpp                 | 107 +++++
 include/common/property.hpp             | 101 +++++
 include/common/queue.hpp                |  88 ++++
 include/common/threading.hpp            | 548 ++++++++++++++++++++++++
 include/common/threadpool.hpp           | 418 ++++++++++++++++++
 include/common/timer.hpp                |  52 +++
 include/common/varstring.hpp            | 249 +++++++++++
 include/gdrive/config.hpp               |  22 +
 include/gdrive/credential.hpp           |  26 ++
 include/gdrive/drive.hpp                |  22 +
 include/gdrive/error.hpp                |  22 +
 include/gdrive/filecontent.hpp          |  22 +
 include/gdrive/gdrive.hpp               |  22 +
 include/gdrive/gitem.hpp                |  22 +
 include/gdrive/oauth.hpp                |  22 +
 include/gdrive/request.hpp              |  22 +
 include/gdrive/service/about.hpp        |  22 +
 include/gdrive/service/apps.hpp         |  22 +
 include/gdrive/service/changes.hpp      |  22 +
 include/gdrive/service/children.hpp     |  22 +
 include/gdrive/service/comments.hpp     |  22 +
 include/gdrive/service/files.hpp        |  22 +
 include/gdrive/service/parents.hpp      |  22 +
 include/gdrive/service/permissions.hpp  |  22 +
 include/gdrive/service/replies.hpp      |  22 +
 include/gdrive/service/revisions.hpp    |  22 +
 include/gdrive/servicerequest.hpp       |  22 +
 include/gdrive/store.hpp                |  22 +
 include/gdrive/util.hpp                 |  22 +
 include/jconer/allocator.hpp            |  48 +++
 include/jconer/arena.hpp                |  32 ++
 include/jconer/dump.hpp                 |  49 +++
 include/jconer/error.hpp                | 101 +++++
 include/jconer/json.hpp                 |  34 ++
 include/jconer/parser.hpp               |  69 +++
 include/jconer/serializer.hpp           | 294 +++++++++++++
 include/jconer/stream.hpp               |  64 +++
 include/jconer/token.hpp                |  91 ++++
 include/jconer/util.hpp                 | 131 ++++++
 include/jconer/value.hpp                | 254 +++++++++++
 libjconer/.gitignore                    |  21 +
 libjconer/.travis.yml                   |  11 +
 libjconer/LICENSE                       |  21 +
 libjconer/Makefile                      |  44 ++
 libjconer/README.md                     | 129 ++++++
 libjconer/grammer                       |  26 ++
 libjconer/include/common/all.hpp        |  17 +
 libjconer/include/common/logging.hpp    | 138 ++++++
 libjconer/include/common/loggingv2.hpp  | 168 ++++++++
 libjconer/include/common/misc.hpp       |  84 ++++
 libjconer/include/common/path.hpp       | 107 +++++
 libjconer/include/common/property.hpp   | 101 +++++
 libjconer/include/common/queue.hpp      |  88 ++++
 libjconer/include/common/threading.hpp  | 548 ++++++++++++++++++++++++
 libjconer/include/common/threadpool.hpp | 418 ++++++++++++++++++
 libjconer/include/common/timer.hpp      |  52 +++
 libjconer/include/common/varstring.hpp  | 249 +++++++++++
 libjconer/include/jconer/allocator.hpp  |  48 +++
 libjconer/include/jconer/arena.hpp      |  32 ++
 libjconer/include/jconer/dump.hpp       |  49 +++
 libjconer/include/jconer/error.hpp      | 101 +++++
 libjconer/include/jconer/json.hpp       |  34 ++
 libjconer/include/jconer/parser.hpp     |  69 +++
 libjconer/include/jconer/serializer.hpp | 294 +++++++++++++
 libjconer/include/jconer/stream.hpp     |  64 +++
 libjconer/include/jconer/token.hpp      |  91 ++++
 libjconer/include/jconer/util.hpp       | 131 ++++++
 libjconer/include/jconer/value.hpp      | 254 +++++++++++
 libjconer/src/allocator.cpp             |  12 +
 libjconer/src/arena.cpp                 | 182 ++++++++
 libjconer/src/dump.cpp                  | 141 ++++++
 libjconer/src/parser.cpp                | 218 ++++++++++
 libjconer/src/stream.cpp                | 371 ++++++++++++++++
 libjconer/src/token.cpp                 |  52 +++
 libjconer/src/value.cpp                 | 398 +++++++++++++++++
 libjconer/test/test_deepcopy.cpp        |  15 +
 libjconer/test/test_dump.cpp            |  33 ++
 libjconer/test/test_load.cpp            |  16 +
 libjconer/test/test_parser.cpp          |  23 +
 libjconer/test/test_serializer.cpp      | 253 +++++++++++
 libjconer/test/test_stream.cpp          |  13 +
 sample/about/about_get.cpp              |   0
 sample/changes/change_get.cpp           |   0
 sample/changes/change_list.cpp          |   0
 sample/children/child_delete.cpp        |   0
 sample/children/child_insert.cpp        |   0
 sample/children/child_list.cpp          |   0
 sample/files/file_delete.cpp            |   0
 sample/files/file_get.cpp               |   0
 sample/files/file_insert.cpp            |   0
 sample/files/file_list.cpp              |   0
 src/about.cpp                           |   0
 src/apps.cpp                            |   0
 src/changes.cpp                         |   0
 src/children.cpp                        |   0
 src/comments.cpp                        |   0
 src/credential.cpp                      |  49 ++-
 src/drive.cpp                           |   0
 src/filecontent.cpp                     |   0
 src/files.cpp                           |   0
 src/gitem.cpp                           |   0
 src/oauth.cpp                           |   0
 src/parents.cpp                         |   0
 src/permissions.cpp                     |   0
 src/replies.cpp                         |   0
 src/request.cpp                         |   0
 src/revisions.cpp                       |   0
 src/servicerequest.cpp                  |   0
 src/store.cpp                           |   0
 test/test_about.cpp                     |   0
 test/test_change.cpp                    |   0
 test/test_children.cpp                  |   0
 test/test_file.cpp                      |   0
 test/test_filestore.cpp                 |   0
 test/test_oauth.cpp                     |   0
 test/test_request.cpp                   |   0
 121 files changed, 8793 insertions(+), 15 deletions(-)
 mode change 100644 => 100755 Makefile
 create mode 100644 include/common/all.hpp
 create mode 100644 include/common/logging.hpp
 create mode 100644 include/common/loggingv2.hpp
 create mode 100644 include/common/misc.hpp
 create mode 100644 include/common/path.hpp
 create mode 100644 include/common/property.hpp
 create mode 100644 include/common/queue.hpp
 create mode 100644 include/common/threading.hpp
 create mode 100644 include/common/threadpool.hpp
 create mode 100644 include/common/timer.hpp
 create mode 100644 include/common/varstring.hpp
 create mode 100644 include/jconer/allocator.hpp
 create mode 100644 include/jconer/arena.hpp
 create mode 100644 include/jconer/dump.hpp
 create mode 100644 include/jconer/error.hpp
 create mode 100644 include/jconer/json.hpp
 create mode 100644 include/jconer/parser.hpp
 create mode 100644 include/jconer/serializer.hpp
 create mode 100644 include/jconer/stream.hpp
 create mode 100644 include/jconer/token.hpp
 create mode 100644 include/jconer/util.hpp
 create mode 100644 include/jconer/value.hpp
 create mode 100755 libjconer/.gitignore
 create mode 100755 libjconer/.travis.yml
 create mode 100755 libjconer/LICENSE
 create mode 100755 libjconer/Makefile
 create mode 100755 libjconer/README.md
 create mode 100755 libjconer/grammer
 create mode 100644 libjconer/include/common/all.hpp
 create mode 100644 libjconer/include/common/logging.hpp
 create mode 100644 libjconer/include/common/loggingv2.hpp
 create mode 100644 libjconer/include/common/misc.hpp
 create mode 100644 libjconer/include/common/path.hpp
 create mode 100644 libjconer/include/common/property.hpp
 create mode 100644 libjconer/include/common/queue.hpp
 create mode 100644 libjconer/include/common/threading.hpp
 create mode 100644 libjconer/include/common/threadpool.hpp
 create mode 100644 libjconer/include/common/timer.hpp
 create mode 100644 libjconer/include/common/varstring.hpp
 create mode 100644 libjconer/include/jconer/allocator.hpp
 create mode 100644 libjconer/include/jconer/arena.hpp
 create mode 100644 libjconer/include/jconer/dump.hpp
 create mode 100644 libjconer/include/jconer/error.hpp
 create mode 100644 libjconer/include/jconer/json.hpp
 create mode 100644 libjconer/include/jconer/parser.hpp
 create mode 100644 libjconer/include/jconer/serializer.hpp
 create mode 100644 libjconer/include/jconer/stream.hpp
 create mode 100644 libjconer/include/jconer/token.hpp
 create mode 100644 libjconer/include/jconer/util.hpp
 create mode 100644 libjconer/include/jconer/value.hpp
 create mode 100755 libjconer/src/allocator.cpp
 create mode 100755 libjconer/src/arena.cpp
 create mode 100755 libjconer/src/dump.cpp
 create mode 100755 libjconer/src/parser.cpp
 create mode 100755 libjconer/src/stream.cpp
 create mode 100755 libjconer/src/token.cpp
 create mode 100755 libjconer/src/value.cpp
 create mode 100755 libjconer/test/test_deepcopy.cpp
 create mode 100755 libjconer/test/test_dump.cpp
 create mode 100755 libjconer/test/test_load.cpp
 create mode 100755 libjconer/test/test_parser.cpp
 create mode 100755 libjconer/test/test_serializer.cpp
 create mode 100755 libjconer/test/test_stream.cpp
 mode change 100644 => 100755 sample/about/about_get.cpp
 mode change 100644 => 100755 sample/changes/change_get.cpp
 mode change 100644 => 100755 sample/changes/change_list.cpp
 mode change 100644 => 100755 sample/children/child_delete.cpp
 mode change 100644 => 100755 sample/children/child_insert.cpp
 mode change 100644 => 100755 sample/children/child_list.cpp
 mode change 100644 => 100755 sample/files/file_delete.cpp
 mode change 100644 => 100755 sample/files/file_get.cpp
 mode change 100644 => 100755 sample/files/file_insert.cpp
 mode change 100644 => 100755 sample/files/file_list.cpp
 mode change 100644 => 100755 src/about.cpp
 mode change 100644 => 100755 src/apps.cpp
 mode change 100644 => 100755 src/changes.cpp
 mode change 100644 => 100755 src/children.cpp
 mode change 100644 => 100755 src/comments.cpp
 mode change 100644 => 100755 src/drive.cpp
 mode change 100644 => 100755 src/filecontent.cpp
 mode change 100644 => 100755 src/files.cpp
 mode change 100644 => 100755 src/gitem.cpp
 mode change 100644 => 100755 src/oauth.cpp
 mode change 100644 => 100755 src/parents.cpp
 mode change 100644 => 100755 src/permissions.cpp
 mode change 100644 => 100755 src/replies.cpp
 mode change 100644 => 100755 src/request.cpp
 mode change 100644 => 100755 src/revisions.cpp
 mode change 100644 => 100755 src/servicerequest.cpp
 mode change 100644 => 100755 src/store.cpp
 mode change 100644 => 100755 test/test_about.cpp
 mode change 100644 => 100755 test/test_change.cpp
 mode change 100644 => 100755 test/test_children.cpp
 mode change 100644 => 100755 test/test_file.cpp
 mode change 100644 => 100755 test/test_filestore.cpp
 mode change 100644 => 100755 test/test_oauth.cpp
 mode change 100644 => 100755 test/test_request.cpp

diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index 15e17b3..de4f035
--- a/Makefile
+++ b/Makefile
@@ -2,7 +2,7 @@ SRC_DIR := ./src
 TEST_SRC_DIR := ./test
 SAMPLE_SRC_DIR := ./sample
 
-INCLUDE_DIR := -I./include
+INCLUDE_DIR := -I./include -I../jconer/include
 
 
 BUILD_DIR := ./build
@@ -13,11 +13,11 @@ LIB := -ljconer -lpthread
 
 THIRD_INC_DIR := -I/home/justin/pkg/curl/include
 THIRD_LIB_DIR := -L/home/justin/pkg/curl/lib
-CPP := g++
-CC := gcc
-AR := ar
+CPP := ${CXX}
+CC := ${CC}
+AR := ${AR}
 
-CFLAG := -O2
+CFLAG := ${CXXFLAGS}
 LFLAG := -O2 -lcurl -L$(LIB_DIR) $(LIB)
 ARFLAG := -rcs
 
@@ -29,8 +29,11 @@ TEST_TARGET := $(patsubst %.cpp, %, $(subst $(TEST_SRC_DIR),$(TESTBIN_DIR), $(TE
 
 ARCHIVE := libgdrive.a
 
-.PHONY:all target test sample $(BUILD_DIR) $(TESTBIN_DIR)
-all: test target sample
+.PHONY:target test sample $(BUILD_DIR) $(TESTBIN_DIR)
+all: jconer gdrive
+jconer:
+	cd libjconer && $(MAKE) && mkdir -p ../lib/ && cp libjconer.a ../lib/
+gdrive: test target sample
 test: $(TESTBIN_DIR) $(TEST_TARGET) target
 target: $(BUILD_DIR) $(OBJ) $(ARCHIVE)
 
@@ -42,6 +45,7 @@ $(BUILD_DIR)/%.o:$(SRC_DIR)/%.cpp
 
 $(ARCHIVE):$(OBJ)
 	$(AR) $(ARFLAG) $@ $(OBJ)
+	${RANLIB}
 
 $(TESTBIN_DIR):
 	mkdir -p $@
diff --git a/include/common/all.hpp b/include/common/all.hpp
new file mode 100644
index 0000000..8c7c082
--- /dev/null
+++ b/include/common/all.hpp
@@ -0,0 +1,17 @@
+#ifndef __COMMON_ALL_HPP__
+#define __COMMON_ALL_HPP__
+
+#include "common/logging.hpp"
+#include "common/loggingv2.hpp"
+#include "common/varstring.hpp"
+#include "common/threading.hpp"
+#include "common/threadpool.hpp"
+#include "common/queue.hpp"
+#include "common/timer.hpp"
+#include "common/property.hpp"
+#include "common/path.hpp"
+#include "common/misc.hpp"
+
+namespace COMMON = common;
+
+#endif
diff --git a/include/common/logging.hpp b/include/common/logging.hpp
new file mode 100644
index 0000000..352cded
--- /dev/null
+++ b/include/common/logging.hpp
@@ -0,0 +1,138 @@
+#ifndef __common_LOGGING_HPP__
+#define __common_LOGGING_HPP__
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <string>
+
+namespace common {
+
+#define CLASS_MAKE_LOGGER \
+    private:\
+            common::Logger _logger;
+#define CLASS_INIT_LOGGER(classname, level)\
+    _logger.setClassName(classname);\
+    _logger.setLevel(level);
+#define CLOG_DEBUG(...) _logger.debug( __func__, __FILE__, __LINE__, __VA_ARGS__)
+#define CLOG_INFO(...) _logger.info( __func__, __FILE__, __LINE__, __VA_ARGS__)
+#define CLOG_WARN(...) _logger.warn(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+#define CLOG_ERROR(...) _logger.error(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+#define CLOG_FATAL(...) _logger.fatal(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+
+
+#define FUNC_MAKE_LOGGER common::Logger __func_logger__;
+#define FUNC_LOGGER_SET_LEVEL(level) __func_logger__.setLevel(level);
+#define FLOG_DEBUG(...) __func_logger__.debug( __func__, __FILE__, __LINE__, __VA_ARGS__)
+#define FLOG_INFO(...) __func_logger__.info( __func__, __FILE__, __LINE__, __VA_ARGS__)
+#define FLOG_WARN(...) __func_logger__.warn(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+#define FLOG_ERROR(...) __func_logger__.error(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+#define FLOG_FATAL(...) __func_logger__.fatal(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+
+static const char* level_literal[] = {
+    "Debug",
+    "Info",
+    "Warn",
+    "Error",
+    "Fatal",
+    NULL
+};
+
+
+enum Level {
+    L_DEBUG = 0,
+    L_INFO,
+    L_WARN,
+    L_ERROR,
+    L_FATAL
+};
+
+enum LoggerType {
+    LT_CLASS,
+    LT_FUNCTION
+};
+
+class Logger {
+    public:
+        Logger()
+            : _level(L_INFO), _type(LT_FUNCTION) {}
+
+        Logger(Level level)
+            : _level(level), _type(LT_FUNCTION) {}
+
+        void setLevel(Level level) { _level = level; }
+        void setClassName(std::string cname) { _cname = cname; _type = LT_CLASS;}
+
+        void debug(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_DEBUG, fmt, va);
+            va_end(va);
+        }
+
+        void info(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_INFO, fmt, va);
+            va_end(va);
+        }
+
+        void warn(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_WARN, fmt, va);
+            va_end(va);
+        }
+
+        void error(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_ERROR, fmt, va);
+            va_end(va);
+        }
+
+        void fatal(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_FATAL, fmt, va);
+            va_end(va);
+        }
+
+    private:
+        Level _level;
+        std::string _cname;
+        LoggerType _type;
+
+        void _log(const char* funcname, const char* filename, int lineno, Level level, const char* fmt, va_list va) {
+            if (level < _level) return;
+            char fullfmt[512];
+            const char* basename = baseFilename(filename);
+            if (_type == LT_FUNCTION) {
+                snprintf(fullfmt, 511, "%s %s @ [%s|%d] %s", level_literal[level], funcname, basename, lineno, fmt);
+            } else {
+                snprintf(fullfmt, 511, "%s %s:%s @ [%s|%d] %s", level_literal[level], _cname.c_str(), funcname, basename, lineno, fmt);
+            }
+            vfprintf(stderr, fullfmt, va);
+
+            if (level == L_ERROR or level == L_FATAL) {
+                fprintf(stderr, "Abort!\n");
+                exit(-1);
+            }
+        }
+
+        const char* baseFilename(const char* path) {
+            const char* p = path + strlen(path);
+            while (p != path) {
+                if (*p == '/') {
+                    return p + 1;
+                }
+                p --;
+            }
+            return path;
+        }
+};
+
+}
+
+#endif
diff --git a/include/common/loggingv2.hpp b/include/common/loggingv2.hpp
new file mode 100644
index 0000000..3525e4c
--- /dev/null
+++ b/include/common/loggingv2.hpp
@@ -0,0 +1,168 @@
+#ifndef __common_LOGGINGV2_HPP__
+#define __common_LOGGINGV2_HPP__
+
+#include <iostream>
+#include <sstream>
+#include <memory>
+#include <cstdlib>
+#include <string.h>
+
+namespace common {
+
+#define LOGGINGV2_NONE 0
+#define LOGGINGV2_DEBUG 1
+#define LOGGINGV2_INFO 2
+#define LOGGINGV2_WARN 3
+#define LOGGINGV2_FATAL 4
+
+#ifdef NONE
+#undef NONE
+#endif
+#define NONE LOGGINGV2_NONE
+
+#ifdef DEBUG
+#undef DEBUG
+#endif
+#define DEBUG LOGGINGV2_DEBUG
+
+#ifdef INFO
+#undef INFO
+#endif
+#define INFO LOGGINGV2_INFO
+
+#ifdef WARN
+#undef WARN
+#endif
+#define WARN LOGGINGV2_WARN
+
+#ifdef FATAL
+#undef FATAL
+#endif
+#define FATAL LOGGINGV2_FATAL
+
+#ifdef NDEBUG
+#define LIMIT LOGGINGV2_INFO
+#else
+#define LIMIT LOGGINGV2_DEBUG
+#endif
+
+#define LOG(severity) COMPACT_LOG_MESSAGE(severity)
+#define COMPACT_LOG_MESSAGE(s) LOG_MESSAGE_ ## s(__FILE__, __LINE__)
+
+#define LOG_MESSAGE_0(file, lineno) common::LogMessage::New(0, file, lineno)
+#define LOG_MESSAGE_1(file, lineno) common::LogMessage::New(1, file, lineno)
+#define LOG_MESSAGE_2(file, lineno) common::LogMessage::New(2, file, lineno)
+#define LOG_MESSAGE_3(file, lineno) common::LogMessage::New(3, file, lineno)
+#define LOG_MESSAGE_4(file, lineno) common::LogMessage::New(4, file, lineno)
+
+#define CHECK_OP(op, x, y)  (((x) op (y))? LOG(NONE) : LOG(FATAL))
+
+#define CHECK_EQ(x, y) CHECK_OP(==, x, y)
+#define CHECK_NE(x, y) CHECK_OP(!=, x, y)
+#define CHECK_GT(x, y) CHECK_OP(>, x, y)
+#define CHECK_GE(x, y) CHECK_OP(>=, x, y)
+#define CHECK_LT(x, y) CHECK_OP(<, x, y)
+#define CHECK_LE(x, y) CHECK_OP(<=, x, y)
+#define CHECK(x) CHECK_EQ(x, true)
+
+#define CHECK_NULL(x) CHECK_OP(==, x, nullptr)
+#define CHECK_NOTNULL(x) CHECK_OP(!=, x, nullptr)
+
+#define LOG_IF(severity, expr) ((expr) ? LOG(severity) : LOG(NONE))
+
+#define LOG_EVERY_N(severity, n) LOG_EVERY_N2(severity, n, __LINE__)
+#define LOG_EVERY_N2(severity, n, line) \
+    static int LOG_OCCURRENCE ## line= 0;\
+    static int LOG_MODULE ## line = (n); \
+    LOG_OCCURRENCE ## line  ++; if (LOG_OCCURRENCE ## line == LOG_MODULE ## line) LOG_OCCURRENCE ## line -= LOG_MODULE ## line; \
+    LOG_IF(severity, LOG_OCCURRENCE ## line == 1)
+
+#define LOG_FIRST_N(severity, n) LOG_FIRST_N2(severity, n, __LINE__) 
+#define LOG_FIRST_N2(severity, n, line) \
+    static int LOG_OCCURRENCE ## line = 0;  \
+    static int LOG_MAX ## line = (n);\
+    LOG_OCCURRENCE ## line ++; \
+    LOG_IF(severity, LOG_OCCURRENCE ## line <= LOG_MAX ## line)
+
+static const char* log_literal[] = {
+    "None",
+    "Debug",
+    "Info",
+    "Warn",
+    "Error",
+    "Fatal",
+    nullptr
+};
+
+class LogMessage {
+    public:
+        LogMessage(int severity, const char* filename, const int lineno) {
+            _severity = severity;
+            _filename = filename;
+            _lineno = lineno;
+            _stream = std::shared_ptr<std::ostringstream>(new std::ostringstream());
+            if (_severity != LOGGINGV2_NONE)
+                (*this) << log_literal[_severity] << " [" << baseFilename(filename) << "|" << lineno << "] ";
+        }
+
+        LogMessage(const LogMessage& other) {
+            _severity = other._severity;
+            _filename = other._filename;
+            _lineno = other._lineno;
+            _stream = other._stream;
+        }
+
+        ~LogMessage() {
+            if (_severity >= LIMIT) {
+              std::cerr << _stream->str();
+            }
+            if (_severity == FATAL) {
+              std::cerr << "Abort" << std::endl;
+              exit(-1);
+            }
+        }
+
+        static LogMessage New(int severity, const char* filename, const int lineno, bool cond = true) {
+            if (cond) {
+              return LogMessage(severity, filename, lineno);
+            } else {
+              return LogMessage(LOGGINGV2_NONE, filename, lineno);
+            }
+        }
+
+        template<class T>
+        LogMessage& operator<<(const T& t) {
+            if (_severity >= LIMIT)
+                (*_stream) << t;
+            return *this;
+        }
+
+        typedef std::basic_ostream<char, std::char_traits<char> > CoutType;
+        typedef CoutType& (*StandardEndLine)(CoutType&);
+
+        LogMessage& operator<<(StandardEndLine manip) {
+            if (_severity >= LIMIT)
+                manip(*_stream);
+            return *this;
+        }
+    private:
+        int _severity;
+        const char* _filename;
+        int _lineno;
+        std::shared_ptr<std::ostringstream> _stream;
+
+        const char* baseFilename(const char* path) {
+            const char* p = path + strlen(path);
+            while (p != path) {
+                if (*p == '/') {
+                    return p + 1;
+                }
+                p --;
+            }
+            return path;
+        }
+};
+
+}
+
+#endif
diff --git a/include/common/misc.hpp b/include/common/misc.hpp
new file mode 100644
index 0000000..08409ea
--- /dev/null
+++ b/include/common/misc.hpp
@@ -0,0 +1,84 @@
+#ifndef __common_MISC_HPP__
+#define __common_MISC_HPP__
+
+#ifdef _WIN32
+#include <windows.h>
+#elif MACOS
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/time.h>
+#include <ctime>
+#else
+#include <unistd.h>
+#include <sys/time.h>
+#include <ctime>
+#endif
+
+#include <map>
+
+namespace common {
+
+typedef std::map<std::string, std::string> string_map;
+
+#define CLASS_NOCOPY(class) \
+    private: \
+        class& operator=(class& other); \
+        class(const class& other);
+
+static inline size_t get_ncpu() {
+#ifdef WIN32
+    SYSTEM_INFO sysinfo;
+    GetSystemInfo(&sysinfo);
+    return sysinfo.dwNumberOfProcessors;
+#elif MACOS
+    int nm[2];
+    size_t len = 4;
+    uint32_t count;
+ 
+    nm[0] = CTL_HW; nm[1] = HW_AVAILCPU;
+    sysctl(nm, 2, &count, &len, NULL, 0);
+ 
+    if(count < 1) {
+    nm[1] = HW_NCPU;
+    sysctl(nm, 2, &count, &len, NULL, 0);
+    if(count < 1) { count = 1; }
+    }
+    return count;
+#else
+    return sysconf(_SC_NPROCESSORS_ONLN);
+#endif
+}
+
+static int64_t get_time_in_micro()
+{
+#ifdef WIN32
+     /* Windows */
+    FILETIME ft;
+    LARGE_INTEGER li;
+
+    /* Get the amount of 100 nano seconds intervals elapsed since January 1, 1601 (UTC) and copy it
+     * to a LARGE_INTEGER structure. */
+    GetSystemTimeAsFileTime(&ft);
+    li.LowPart = ft.dwLowDateTime;
+    li.HighPart = ft.dwHighDateTime;
+
+    int64_t ret = li.QuadPart;
+    ret -= 116444736000000000LL; /* Convert from file time to UNIX epoch time. */
+    ret /= 1000; /* From 100 nano seconds (10^-7) to 1 millisecond (10^-3) intervals */
+
+    return ret;
+#else
+    /* Linux */
+    struct timeval tval;
+
+    gettimeofday(&tval, NULL);
+
+    int64_t ret = tval.tv_usec;
+    /* Adds the seconds (10^0) after converting them to milliseconds (10^-3) */
+    ret += (tval.tv_sec * 1000000);
+    return ret;
+#endif
+} 
+}
+
+#endif
diff --git a/include/common/path.hpp b/include/common/path.hpp
new file mode 100644
index 0000000..07700be
--- /dev/null
+++ b/include/common/path.hpp
@@ -0,0 +1,107 @@
+#ifndef __common_PATH_HPP__
+#define __common_PATH_HPP__
+
+#include "common/varstring.hpp"
+#include <stdlib.h>
+#include <string.h>
+#include <utility>
+#include <iostream>
+#include <fstream>
+
+namespace common {
+    
+class Path {
+    public:
+        static inline std::string sep() {
+#ifdef Win32
+            static std::string _sep = "\\";
+#else
+            static std::string _sep = "/";
+#endif
+            return _sep;
+        }
+
+#ifndef Win32
+        static inline std::string devnull() {
+            static std::string _devnull = "/dev/null";
+            return _devnull;
+        }
+#endif
+
+        static inline std::string curdir() {
+            static std::string _curdir = ".";
+            return _curdir;
+        }
+
+        static inline std::string parentdir() {
+            static std::string _parentdir = "..";
+            return _parentdir;
+        }
+
+        static inline std::string pathsep() {
+#ifdef Win32
+            static std::string _pathsep = ";";
+#else
+            static std::string _pathsep = ":";
+#endif
+            return _pathsep;
+        }
+
+        static std::pair<std::string, std::string> split(const std::string& path) {
+            std::string::size_type pos = path.rfind(Path::sep());
+            std::string dir = "", base = "";
+            if (pos != std::string::npos) {
+                dir = path.substr(0, pos);
+                pos ++;
+                base = path.substr(pos);
+            } else {
+                base = path;
+            }
+            return make_pair(dir, base);
+        }
+
+        static std::string join(const std::string& dir, const std::string & base) {
+            std::string rst = "";
+            if (VarString::starts_with(base, Path::sep())) {
+                rst = base;
+            } else {
+                if (VarString::ends_with(dir, Path::sep())) {
+                    rst = dir + base;
+                } else {
+                    rst = dir + Path::sep() + base;
+                }
+            }
+            return rst;
+        }
+
+        static std::string basename(const std::string& path) {
+            return Path::split(path).first;
+        }
+
+        static std::string dirname(const std::string& path) {
+            return Path::split(path).second;
+        }
+
+        static std::pair<std::string, std::string> splitext(const std::string& path) {
+            std::string::size_type pos = path.rfind(".");
+            std::string name = "", ext = "";
+            if (pos != std::string::npos) {
+                name = path.substr(0, pos);
+                ext = path.substr(pos);
+            } else {
+                name = path;
+            }
+            return make_pair(name, ext);
+        }
+
+        static bool exists(const std::string& path) {
+            std::ifstream  fin(path.c_str());
+            bool rst = fin.good();
+            fin.close();
+            return rst;
+        }
+};
+
+}
+
+#endif
diff --git a/include/common/property.hpp b/include/common/property.hpp
new file mode 100644
index 0000000..7940082
--- /dev/null
+++ b/include/common/property.hpp
@@ -0,0 +1,101 @@
+#ifndef __COMMON_PROPERTY_HPP__
+#define __COMMON_PROPERTY_HPP__
+
+#include "common/misc.hpp"
+#include "common/varstring.hpp"
+
+#include <iostream>
+#include <fstream>
+#include <sstream>
+#include <vector>
+
+namespace common {
+
+class Property {
+    public:
+        Property(std::string filename)
+            :_in(* new std::ifstream(filename.c_str())), _own(true)
+        {
+        }
+        Property(std::istream& in)
+            :_in(in), _own(false)
+        {
+            _property.clear();
+            _parse();
+        }
+        ~Property() {
+            if (_own) {
+                ((std::ifstream*)(&_in))->close();
+                delete &_in;
+            }
+        }
+
+        std::string get(std::string key, std::string d = "") {
+            if (_property.find(key) != _property.end())
+                return _property[key];
+            return d;
+        }
+
+        int get_int(std::string key, int d = 0) {
+            std::string value = get(key);
+            if (value == "") {
+                return d;
+            } else {
+                return atoi(value.c_str());
+            }
+        }
+
+        double get_real(std::string key, double d = 0.0) {
+            std::string value = get(key);
+            if (value == "") {
+                return d;
+            } else {
+                return atof(value.c_str());
+            }
+        }
+
+        bool get_bool(std::string key, bool d = false) {
+            std::string value = get(key);
+            if (value == "") {
+                return d;
+            } else {
+                std::string lower = VarString::tolower(value);
+                if (lower == "false" || lower == "0") return false;
+                if (lower == "true" || lower == "1") return true;
+                return d;
+            }
+        }
+
+    private:
+        std::istream& _in;
+        bool _own;
+        string_map _property;
+
+        void _parse(){
+            while(true) {
+                std::string line;
+                getline(_in, line);
+                if (_in.good()) {
+                    if (line == "" || line[0] == '#') {
+                        continue;
+                    } else {
+                        std::vector<std::string> parts = VarString::split(line, "=");
+                        if (parts.size() == 1) {
+                            continue;
+                        } else {
+                            std::string key = VarString::strip(parts[0]);
+                            std::string value = VarString::strip(parts[1]);
+                            _property[key] = value;
+                            std::cout << key << " " << value << std::endl;
+                        }
+                    }
+                } else {
+                    break;
+                }
+            }
+        }
+};
+
+}
+
+#endif
diff --git a/include/common/queue.hpp b/include/common/queue.hpp
new file mode 100644
index 0000000..ae449b2
--- /dev/null
+++ b/include/common/queue.hpp
@@ -0,0 +1,88 @@
+#ifndef __common_QUEUE_HPP__
+#define __common_QUEUE_HPP__
+
+#include "common/misc.hpp"
+#include "common/threading.hpp"
+#include <pthread.h>
+#include <deque>
+#include <stdio.h>
+
+namespace common {
+
+template<class T>
+class Queue {
+    public:
+        Queue(size_t size = 0)
+            :_lock(), _empty_cond(&_lock), _full_cond(&_lock), _size(size)
+        {
+        }
+        ~Queue() {
+            _queue.clear();
+        }
+
+        void push(const T& item) {
+            _lock.lock();
+            size_t queue_size = _queue.size();
+            if (_size != 0 && queue_size == _size) {
+                _full_cond.wait();
+                _queue.push_back(item);
+            } else {
+                _queue.push_back(item);
+                _empty_cond.notify();
+            }
+            _lock.unlock();
+        }
+
+        bool try_pop(T* item) {
+            _lock.lock();
+            size_t queue_size = _queue.size();
+            bool rst = false;
+            if (queue_size != 0) {
+                *item = _queue.front();
+                _queue.pop_front();
+                rst = true;
+                if (queue_size == _size - 1) {
+                    _full_cond.notify();
+                }
+            }
+            _lock.unlock();
+            return rst;
+        }
+        
+        T pop() {
+            _lock.lock();
+            while(_queue.empty()) {
+                _empty_cond.wait();
+            }
+
+            T item = _queue.front();
+            _queue.pop_front();
+            if (_queue.size() == _size - 1) {
+                _full_cond.notify();
+            }
+            _lock.unlock();
+            return item;
+        }
+
+        size_t size() {
+            _lock.lock();
+            size_t size = _queue.size();
+            _lock.unlock();
+            return size;
+        }
+
+        size_t capacity() const { return _size; }
+        void clear() { _queue.clear(); }
+
+    private:
+        std::deque<T> _queue;
+        Mutex _lock;
+        Condition _empty_cond;
+        Condition _full_cond;
+        size_t _size;
+};
+
+
+}
+
+#endif
diff --git a/include/common/threading.hpp b/include/common/threading.hpp
new file mode 100644
index 0000000..c7426f3
--- /dev/null
+++ b/include/common/threading.hpp
@@ -0,0 +1,548 @@
+#ifndef __common_THREADING_HPP__
+#define __common_THREADING_HPP__
+
+#include <pthread.h>
+#include <stdio.h>
+#include <time.h>
+#include "common/misc.hpp"
+
+namespace common {
+
+class Lock {
+    CLASS_NOCOPY(Lock)
+    public:
+        Lock(){}
+        virtual void lock() = 0;
+        virtual void unlock() = 0;
+        virtual ~Lock() {}
+};
+
+class Mutex : public Lock {
+    CLASS_NOCOPY(Mutex)
+    public:
+        Mutex() {
+            pthread_mutex_init(&_lock, NULL);
+        }
+        ~Mutex() {
+            pthread_mutex_destroy(&_lock);
+        }
+        void lock() {
+            pthread_mutex_lock(&_lock);
+        }
+        void unlock() {
+            pthread_mutex_unlock(&_lock);
+        }
+    private:
+        pthread_mutex_t _lock;
+        friend class Condition;
+};
+
+class RecursiveMutex : public Lock {
+    CLASS_NOCOPY(RecursiveMutex)
+    public:
+        RecursiveMutex() {
+            pthread_mutexattr_init(&_attr);
+            pthread_mutexattr_settype(&_attr, PTHREAD_MUTEX_RECURSIVE);
+
+            pthread_mutex_init(&_lock, &_attr);
+        }
+        ~RecursiveMutex() {
+            pthread_mutexattr_destroy(&_attr);
+            pthread_mutex_destroy(&_lock);
+        }
+        void lock() {
+            pthread_mutex_lock(&_lock);
+        }
+        void unlock() {
+            pthread_mutex_unlock(&_lock);
+        }
+    private:
+        pthread_mutex_t _lock;
+        pthread_mutexattr_t _attr;
+        friend class Condition;
+};
+
+class ScopeLock {
+    public:
+        ScopeLock(Lock* lock) {
+            _lock = lock;
+            _lock->lock();
+        }
+        ~ScopeLock() {
+            _lock->unlock();
+        }
+    private:
+        Lock* _lock;
+};
+
+class Condition {
+    CLASS_NOCOPY(Condition)
+    public:
+        Condition(Mutex* lock) {
+            _lock = lock;
+            pthread_cond_init(&_cond, NULL);
+        }
+        ~Condition(){
+            pthread_cond_destroy(&_cond);
+        }
+
+        void wait() {
+            pthread_cond_wait(&_cond, &_lock->_lock); 
+        }
+
+        void notify() {
+            pthread_cond_signal(&_cond);
+        }
+
+        void notify_all() {
+            pthread_cond_broadcast(&_cond);
+        }
+    private:
+        pthread_cond_t _cond;
+        Mutex* _lock;
+};
+
+class Runable {
+    public:
+        virtual void run() = 0;
+        virtual ~Runable(){}
+};
+
+class Thread: public Runable {
+    public:
+        Thread(const Runable& runable) {
+            _joinable = true;
+            _active = false;
+            _context = &runable;
+        }
+        Thread() {
+            _joinable = true;
+            _active = false;
+            _context = NULL;
+        }
+
+        virtual void run() {
+        }
+
+        bool start() {
+            if (_active == true) {
+                return false;
+            }
+            if (_context == NULL) {
+                _context = this;
+            }
+
+            int r = pthread_create(&_thread_id, NULL, &Thread::_run_thread, (void*)_context);
+            if (r != 0) {
+                return false;
+            }
+            _active = true;
+            return true;
+        }
+
+        long thread_id() const { return (long)_thread_id; }
+
+        bool join() {
+            if (_joinable == false) return false;
+
+            int r = pthread_join(_thread_id, NULL);
+
+            if (r != 0) {
+                return false;
+            }
+            _active = false;
+            return true;
+        }
+
+        bool is_active() {
+            return _active;
+        }
+
+        virtual ~Thread() {
+            if (_active)
+                join();
+        }
+
+    private:
+        static void* _run_thread(void* context) {
+            Runable * self = (Runable*)context;
+            self->run();
+            pthread_exit(NULL);
+            return NULL;
+        }
+
+        pthread_t _thread_id;
+        const Runable * _context;
+
+        bool _active;
+        bool _joinable;
+};
+
+class AsyncMethod {
+    public:
+        AsyncMethod(): _runable(NULL), _thread(NULL) {
+        }
+        void start_async(void (*fn) (void) ) {
+            _check();
+            typedef void (*FUNC) (void);
+            class VVRunable : public Runable {
+                public:
+                    VVRunable(FUNC fn) : _fn(fn) {
+                    }
+                    void run() {
+                        _fn();
+                    }
+                private:
+                    FUNC _fn;
+            };
+            _runable = new VVRunable(fn);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class R>
+        void start_async(R (*fn) (void), R* r) {
+            _check();
+            typedef R (*FUNC) (void);
+
+            class RVRunable : public Runable {
+                public:
+                    RVRunable(FUNC fn, R* r) : _fn(fn), _r(r){
+                    }
+                    void run() {
+                        *_r = _fn();
+                    }
+                private:
+                    FUNC _fn;
+                    R* _r;
+            };
+
+            _runable = new  RVRunable(fn, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class A1>
+        void start_async(void (*fn) (A1) , A1 a1) {
+            _check();
+            typedef void (*FUNC) (A1);
+
+            class VA1Runable : public Runable {
+                public:
+                    VA1Runable(FUNC fn, A1 a1) : _fn(fn), _a1(a1){
+                    }
+                    void run() {
+                        _fn(_a1);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+            };
+
+            _runable = new  VA1Runable(fn, a1);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C>
+        void start_async(void (C::*fn)(), C* c) {
+            _check();
+            typedef void (C::*FUNC)();
+            class VCVRunable : public Runable {
+                public:
+                    VCVRunable(FUNC fn, C* c) : _fn(fn), _c(c){
+                    }
+                    void run() {
+                        (_c->*_fn)();
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+            };
+
+            _runable = new  VCVRunable(fn, c);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class A1, class R>
+        void start_async(R (*fn) (A1), A1 a1, R*r) {
+            _check();
+            typedef R (*FUNC) (A1);
+
+            class RA1Runable : public Runable {
+                public:
+                    RA1Runable(FUNC fn, A1 a1, R* r) : _fn(fn), _a1(a1), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    R* _r;
+            };
+
+            _runable = new RA1Runable(fn, a1, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class R>
+        void start_async(R (C::*fn) (), C* c, R* r) {
+            _check();
+            typedef R (C::*FUNC) ();
+
+            class RCVRunable : public Runable {
+                public:
+                    RCVRunable(FUNC fn, C* c, R* r) : _fn(fn), _c(c), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)();
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    R* _r;
+            };
+
+            _runable = new RCVRunable(fn, c, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+
+        template<class A1, class A2>
+        void start_async(void (*fn) (A1, A2) , A1 a1, A2 a2) {
+            _check();
+            typedef void (*FUNC) (A1, A2);
+
+            class VA2Runable : public Runable {
+                public:
+                    VA2Runable(FUNC fn, A1 a1, A2 a2) : _fn(fn), _a1(a1), _a2(a2) {
+                    }
+                    void run() {
+                        _fn(_a1, _a2);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+            };
+
+            _runable = new  VA2Runable(fn, a1, a2);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class A1>
+        void start_async(void (C::*fn) (A1), C* c, A1 a1) {
+            _check();
+            typedef void (C::*FUNC) (A1);
+
+            class VCA1Runable : public Runable {
+                public:
+                    VCA1Runable(FUNC fn, C* c, A1 a1) : _fn(fn), _c(c), _a1(a1) {
+                    }
+                    void run() {
+                        (_c->*_fn)(_a1);
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+            };
+
+            _runable = new  VCA1Runable(fn, c, a1);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+
+        template<class A1, class A2, class R>
+        void start_async(R (*fn) (A1, A2), A1 a1, A2 a2, R*r) {
+            _check();
+            typedef R (*FUNC) (A1, A2);
+
+            class RA2Runable : public Runable {
+                public:
+                    RA2Runable(FUNC fn, A1 a1, A2 a2, R* r) : _fn(fn), _a1(a1), _a2(a2), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1, _a2);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    R* _r;
+            };
+
+            _runable = new RA2Runable(fn, a1, a2, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class A1, class R>
+        void start_async(R (C::*fn) (A1), C* c, A1 a1, R*r) {
+            _check();
+            typedef R (C::*FUNC) (A1);
+
+            class RCA1Runable : public Runable {
+                public:
+                    RCA1Runable(FUNC fn, C* c, A1 a1, R* r) : _fn(fn), _c(c), _a1(a1), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)(_a1);
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    R* _r;
+            };
+
+            _runable = new RCA1Runable(fn, c, a1, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+
+        template<class A1, class A2, class A3>
+        void start_async(void (*fn) (A1, A2, A3) , A1 a1, A2 a2, A3 a3) {
+            _check();
+            typedef void (*FUNC) (A1, A2, A3);
+
+            class VA3Runable : public Runable {
+                public:
+                    VA3Runable(FUNC fn, A1 a1, A2 a2, A3 a3) : _fn(fn), _a1(a1), _a2(a2), _a3(a3){
+                    }
+                    void run() {
+                        _fn(_a1, _a2, _a3);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    A3 _a3;
+            };
+
+            _runable = new  VA3Runable(fn, a1, a2, a3);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class A1, class A2>
+        void start_async(void (C::*fn) (A1, A2) , C* c, A1 a1, A2 a2) {
+            _check();
+            typedef void (C::*FUNC) (A1, A2);
+
+            class VCA2Runable : public Runable {
+                public:
+                    VCA2Runable(FUNC fn, C* c, A1 a1, A2 a2) : _fn(fn), _c(c), _a1(a1), _a2(a2){
+                    }
+                    void run() {
+                        (_c->*_fn)(_a1, _a2);
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    A2 _a2;
+            };
+
+            _runable = new  VCA2Runable(fn, c, a1, a2);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class A1, class A2, class A3, class R>
+        void start_async(R (*fn) (A1, A2, A3), A1 a1, A2 a2, A3 a3, R*r) {
+            _check();
+            typedef R (*FUNC) (A1, A2, A3);
+
+            class RA3Runable : public Runable {
+                public:
+                    RA3Runable(FUNC fn, A1 a1, A2 a2, A3 a3, R* r) : _fn(fn), _a1(a1), _a2(a2), _a3(a3), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1, _a2, _a3);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    A3 _a3;
+                    R* _r;
+            };
+
+            _runable = new RA3Runable(fn, a1, a2, a3, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class A1, class A2, class R>
+        void start_async(R (C::*fn) (A1, A2), C* c, A1 a1, A2 a2, R*r) {
+            _check();
+            typedef R (C::*FUNC) (A1, A2);
+
+            class RCA2Runable : public Runable {
+                public:
+                    RCA2Runable(FUNC fn, C* c, A1 a1, A2 a2, R* r) : _fn(fn), _c(c), _a1(a1), _a2(a2), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)(_a1, _a2);
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    A2 _a2;
+                    R* _r;
+            };
+
+            _runable = new RCA2Runable(fn, c, a1, a2, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+
+        void wait() {
+          _thread->join();
+        }
+
+        ~AsyncMethod() {
+            _thread->join();
+            if (_runable) delete _runable;
+            if (_thread) delete _thread;
+        }
+
+    private:
+        Runable *_runable;
+        Thread *_thread;
+
+
+        void _check(){
+          if (_runable != nullptr) {
+            _thread->join();
+            delete _runable;
+            delete _thread;
+          }
+        }
+};
+
+}
+
+#endif
diff --git a/include/common/threadpool.hpp b/include/common/threadpool.hpp
new file mode 100644
index 0000000..de2f60a
--- /dev/null
+++ b/include/common/threadpool.hpp
@@ -0,0 +1,418 @@
+#ifndef __common_THREADPOOL_HPP__
+#define __common_THREADPOOL_HPP__
+
+#include "common/misc.hpp"
+#include "common/queue.hpp"
+#include <time.h>
+#include <pthread.h>
+#include <assert.h>
+#include <stdio.h>
+#include <functional>
+
+namespace common {
+
+typedef void (*func) (void*);
+
+class Job {
+    public:
+        virtual void run() = 0;
+        virtual ~Job() {}
+};
+
+#define TP_IMMEDIATE_SHUTDOWN 0
+#define TP_POSTPONED_SHUTDOWN 1
+
+class ThreadPool {
+    CLASS_NOCOPY(ThreadPool)
+    public:
+        ThreadPool(size_t pool_size = get_ncpu(), size_t queue_size = 2 * get_ncpu())
+            :_task_queue(queue_size), _pool_size(pool_size)
+        {
+            pthread_mutex_init(&_lock, NULL);
+            _stop = false;
+            _shutdown = -1;
+            assert(_pool_size > 0);
+            _pool = (pthread_t*) malloc(sizeof(pthread_t) * _pool_size);
+            assert(_pool != NULL);
+            _active_count = 0;
+
+            pthread_mutex_lock(&_lock);
+            size_t i;
+            for(i = 0; i < _pool_size; i ++ ) {
+                int ret = pthread_create(&_pool[i], NULL, _run_thread, (void*)this);
+                if (ret != 0) {
+                    pthread_mutex_unlock(&_lock);
+                    destroy();
+                    break;
+                } else {
+                    _active_count ++;
+                }
+            }
+            if (i == _pool_size) pthread_mutex_unlock(&_lock);
+        }
+
+        void destroy(int shutdown = TP_IMMEDIATE_SHUTDOWN) {
+            if (shutdown != TP_IMMEDIATE_SHUTDOWN && shutdown != TP_POSTPONED_SHUTDOWN) {
+                _shutdown = TP_IMMEDIATE_SHUTDOWN;
+            } else {
+                _shutdown = shutdown;
+            }
+            for(size_t i = 0; i < _active_count; i ++ ) {
+                pthread_join(_pool[i], NULL);
+            }
+            _task_queue.clear();
+            free(_pool);
+            _pool = NULL;
+            _stop = true;
+        }
+
+        bool add(void (*fn) (void) ) {
+            typedef void (*FUNC) (void);
+            class VVJob : public Job {
+                public:
+                    VVJob(FUNC fn) : _fn(fn) {
+                    }
+                    void run() {
+                        _fn();
+                    }
+                private:
+                    FUNC _fn;
+            };
+            _task_queue.push(new VVJob(fn));
+            return true;
+        }
+
+        template<class C>
+        bool add(void (C::*fn) (void), C* c) {
+            typedef void (C::*FUNC) (void);
+            class VCVJob : public Job {
+                public:
+                    VCVJob(FUNC fn, C* c) : _fn(fn), _c(c) {
+                    }
+                    void run() {
+                        (_c->*_fn)();
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+            };
+            _task_queue.push(new VCVJob(fn, c));
+            return true;
+        }
+
+
+        template<class R>
+        bool add(R (*fn)(void), R* r) {
+            typedef R (*FUNC) (void);
+
+            class RVJob : public Job {
+                public:
+                    RVJob(FUNC fn, R* r) : _fn(fn), _r(r){
+                    }
+                    void run() {
+                        *_r = _fn();
+                    }
+                private:
+                    FUNC _fn;
+                    R* _r;
+            };
+
+            _task_queue.push(new  RVJob(fn, r));
+            return true;
+        }
+
+        template<class C, class R>
+        bool add(R (C::*fn)(void), C* c, R* r) {
+            typedef R (C::*FUNC) (void);
+
+            class RCVJob : public Job {
+                public:
+                    RCVJob(FUNC fn, C* c, R* r) : _fn(fn), _c(c), _r(r){
+                    }
+                    void run() {
+                        *_r = (_c->*_fn)();
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    R* _r;
+            };
+
+            _task_queue.push(new  RCVJob(fn, c, r));
+            return true;
+        }
+
+
+        template<class A1>
+        bool add(void (*fn) (A1) , A1 a1) {
+            typedef void (*FUNC) (A1);
+
+            class VA1Job : public Job {
+                public:
+                    VA1Job(FUNC fn, A1 a1) : _fn(fn), _a1(a1){
+                    }
+                    void run() {
+                        _fn(_a1);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+            };
+
+            _task_queue.push(new  VA1Job(fn, a1));
+            return true;
+        }
+
+        template<class C, class A1>
+        bool add(void (C::*fn) (A1) , C* c, A1 a1) {
+            typedef void (C::*FUNC) (A1);
+
+            class VCA1Job : public Job {
+                public:
+                    VCA1Job(FUNC fn, C* c, A1 a1) : _fn(fn), _c(c), _a1(a1){
+                    }
+                    void run() {
+                        (_c->*_fn)(_a1);
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+            };
+
+            _task_queue.push(new  VCA1Job(fn, c, a1));
+            return true;
+        }
+
+        template<class A1, class R>
+        bool add(R (*fn) (A1), A1 a1, R*r) {
+            typedef R (*FUNC) (A1);
+
+            class RA1Job : public Job {
+                public:
+                    RA1Job(FUNC fn, A1 a1, R* r) : _fn(fn), _a1(a1), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    R* _r;
+            };
+
+            _task_queue.push(new RA1Job(fn, a1, r));
+            return true;
+        }
+
+        template<class C, class A1, class R>
+        bool add(R (C::*fn) (A1), C* c, A1 a1, R*r) {
+            typedef R (C::*FUNC) (A1);
+
+            class RCA1Job : public Job {
+                public:
+                    RCA1Job(FUNC fn, C* c, A1 a1, R* r) : _fn(fn), _c(c), _a1(a1), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)(_a1);
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    R* _r;
+            };
+
+            _task_queue.push(new RCA1Job(fn, c, a1, r));
+            return true;
+        }
+
+        template<class A1, class A2>
+        bool add(void (*fn) (A1, A2) , A1 a1, A2 a2) {
+            typedef void (*FUNC) (A1, A2);
+
+            class VA2Job : public Job {
+                public:
+                    VA2Job(FUNC fn, A1 a1, A2 a2) : _fn(fn), _a1(a1), _a2(a2) {
+                    }
+                    void run() {
+                        _fn(_a1, _a2);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+            };
+
+            _task_queue.push(new  VA2Job(fn, a1, a2));
+            return true;
+        }
+
+        template<class C, class A1, class A2>
+        bool add(void (C::*fn) (A1, A2) , C* c, A1 a1, A2 a2) {
+            typedef void (C::*FUNC) (A1, A2);
+
+            class VCA2Job : public Job {
+                public:
+                    VCA2Job(FUNC fn, C* c, A1 a1, A2 a2) : _fn(fn), _c(c), _a1(a1), _a2(a2) {
+                    }
+                    void run() {
+                        (_c->*_fn)(_a1, _a2);
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    A2 _a2;
+            };
+
+            _task_queue.push(new  VCA2Job(fn, c, a1, a2));
+            return true;
+        }
+
+        template<class A1, class A2, class R>
+        bool add(R (*fn) (A1, A2), A1 a1, A2 a2, R*r) {
+            typedef R (*FUNC) (A1, A2);
+
+            class RA2Job : public Job {
+                public:
+                    RA2Job(FUNC fn, A1 a1, A2 a2, R* r) : _fn(fn), _a1(a1), _a2(a2), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1, _a2);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    R* _r;
+            };
+
+            _task_queue.push(new RA2Job(fn, a1, a2, r));
+            return true;
+        }
+
+        template<class C, class A1, class A2, class R>
+        bool add(R (C::*fn) (A1, A2), C* c, A1 a1, A2 a2, R*r) {
+            typedef R (C::*FUNC) (A1, A2);
+
+            class RCA2Job : public Job {
+                public:
+                    RCA2Job(FUNC fn, C* c, A1 a1, A2 a2, R* r) : _fn(fn), _c(c), _a1(a1), _a2(a2), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)(_a1, _a2);
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    A2 _a2;
+                    R* _r;
+            };
+
+            _task_queue.push(new RCA2Job(fn, c, a1, a2, r));
+            return true;
+        }
+
+
+        template<class A1, class A2, class A3>
+        bool add(void (*fn) (A1, A2, A3) , A1 a1, A2 a2, A3 a3) {
+            typedef void (*FUNC) (A1, A2, A3);
+
+            class VA3Job : public Job {
+                public:
+                    VA3Job(FUNC fn, A1 a1, A2 a2, A3 a3) : _fn(fn), _a1(a1), _a2(a2), _a3(a3){
+                    }
+                    void run() {
+                        _fn(_a1, _a2, _a3);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    A3 _a3;
+            };
+
+            _task_queue.push(new  VA3Job(fn, a1, a2, a3));
+            return true;
+        }
+
+        template<class A1, class A2, class A3, class R>
+        bool add(R (*fn) (A1, A2, A3), A1 a1, A2 a2, A3 a3, R*r) {
+            typedef R (*FUNC) (A1, A2, A3);
+
+            class RA3Job : public Job {
+                public:
+                    RA3Job(FUNC fn, A1 a1, A2 a2, A3 a3, R* r) : _fn(fn), _a1(a1), _a2(a2), _a3(a3), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1, _a2, _a3);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    A3 _a3;
+                    R* _r;
+            };
+
+            _task_queue.push(new RA3Job(fn, a1, a2, a3, r));
+            return true;
+        }
+        
+
+        ~ThreadPool() {
+            if (!_stop) {
+                destroy();
+            }
+        }
+    private:
+        Queue<Job*> _task_queue;
+        pthread_mutex_t _lock;
+        pthread_t* _pool;
+        int _shutdown;
+        size_t _pool_size;
+        bool _stop;
+        size_t _active_count;
+
+        static void* _run_thread(void* context) {
+            ThreadPool* self = (ThreadPool*)context;
+
+            for(;;) {
+                if (self->_shutdown == TP_IMMEDIATE_SHUTDOWN) {
+                    break;
+                } else if (self->_shutdown == TP_POSTPONED_SHUTDOWN && self->_task_queue.size() == 0) {
+                    //fprintf(stderr, "Postponed shutdown");
+                    break;
+                }
+
+                Job* job = nullptr;
+                if (self->_task_queue.try_pop(&job)) {
+                    job->run();
+                    delete job;
+                } else {
+                    struct timespec ts;
+                    ts.tv_sec = 0;
+                    ts.tv_nsec = 1000; // 1us
+                    nanosleep(&ts, NULL);
+                }
+            }
+            pthread_exit(NULL);
+            return NULL;
+        }
+};
+
+}
+
+#endif
diff --git a/include/common/timer.hpp b/include/common/timer.hpp
new file mode 100644
index 0000000..eafaa71
--- /dev/null
+++ b/include/common/timer.hpp
@@ -0,0 +1,52 @@
+#ifndef __common_TIMER_HPP__
+#define __common_TIMER_HPP__
+
+#include <string.h>
+
+#include "common/misc.hpp"
+
+namespace common {
+
+
+class Timer {
+    CLASS_NOCOPY(Timer)
+    public:
+        Timer() {
+            _start = get_time_in_micro();
+        }
+
+        void start() {
+            _start = get_time_in_micro();
+        }
+
+        int64_t elapsed() {
+            _end = get_time_in_micro();
+            return _end - _start;
+        }
+
+
+    private:
+        int64_t _start;
+        int64_t _end;
+};
+
+class ScopeTimer {
+    public:
+        ScopeTimer(const char* name)
+            :_timer(), _name(name) 
+        {
+        }
+
+        ~ScopeTimer() {
+            int64_t elapsed = _timer.elapsed();
+            fprintf(stderr, "[%s]: %fs\n", _name.c_str(), elapsed * 1.0 / 1000000);
+        }
+
+    private:
+        Timer _timer;
+        std::string  _name;
+};
+
+}
+
+#endif
diff --git a/include/common/varstring.hpp b/include/common/varstring.hpp
new file mode 100644
index 0000000..1297de3
--- /dev/null
+++ b/include/common/varstring.hpp
@@ -0,0 +1,249 @@
+#ifndef __common_VARSTRING_HPP__
+#define __common_VARSTRING_HPP__
+#include <string>
+#include <map>
+#include <set>
+#include <vector>
+#include <cctype>
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#define BUFSIZE 1024
+#define MALLOC(type, ptr, size) do {\
+    if (((ptr) = (type*)malloc(size)) == NULL) {\
+        fprintf(stderr, "Run out of memory at %s, %d\n", __FILE__, __LINE__);\
+        exit(-1);\
+    }\
+} while(0)
+
+#define REALLOC(type, ptr, size)  do {\
+    if (((ptr) = (type*)realloc(ptr, size)) == NULL) {\
+        fprintf(stderr, "Run out of memory at %s, %d\n", __FILE__, __LINE__);\
+        exit(-1);\
+    }\
+} while(0)
+
+
+
+namespace common {
+
+class VarString {
+    public:
+        static std::string tolower(const std::string str) {
+            size_t size = str.size();
+            const char* p_str = str.c_str();
+            char* rst = NULL;
+            MALLOC(char, rst, size);
+            for(size_t i = 0; i < size; i ++ ) {
+                if (p_str[i] <= 'Z' && p_str[i] >= 'A') {
+                    rst[i] = p_str[i] + 32;
+                }
+                else {
+                    rst[i] = p_str[i];
+                }
+            }
+            std::string str_rst(rst, size);
+            free(rst);
+            return str_rst;
+        }
+
+        static std::string toupper(const std::string str) {
+            size_t size = str.size();
+            const char* p_str = str.c_str();
+            char* rst = NULL;
+            MALLOC(char, rst, size);
+            for(size_t i = 0; i < size; i ++ ) {
+                if (p_str[i] <= 'z' && p_str[i] >= 'a') {
+                    rst[i] = p_str[i] - 32;
+                }
+                else {
+                    rst[i] = p_str[i];
+                }
+            }
+            std::string str_rst(rst, size);
+            free(rst);
+            return str_rst;
+        }
+        
+        static std::string itos(int i) {
+            char tmp[20];
+            sprintf(tmp, "%d", i);
+            return std::string(tmp);
+        }
+
+        static std::string join(std::set<std::string> vec, std::string sep) {
+            if (vec.size() == 0) return "";
+            VarString vs;
+            int len = sep.size();
+            //for(int i = 0; i < vec.size(); i ++ ) {
+            for(std::set<std::string>::iterator iter = vec.begin();
+                    iter != vec.end(); iter ++) {
+                vs.append(*iter).append(sep);
+            }
+            vs.drop(len);
+            return vs.toString();
+        }
+
+        static std::vector<std::string> split(const std::string str, const std::string delim) {
+            std::vector<std::string> rst;
+            size_t pos = 0;
+            while(true) {
+                size_t next = str.find(delim, pos);
+                if (next != std::string::npos) {
+                    rst.push_back(str.substr(pos, next - pos));
+                    pos = next + delim.size();
+                } else {
+                    rst.push_back(str.substr(pos));
+                    break;
+                }
+            }
+            return rst;
+        }
+
+        static std::string format(const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            char fullstring[1024];
+            vsnprintf(fullstring, 1023, fmt, va);
+            va_end(va);
+            return std::string(fullstring);
+        }
+
+        static bool starts_with(const std::string str, const std::string prefix) {
+            return str.compare(0, prefix.size(), prefix) == 0;
+        }
+
+        static bool ends_with(const std::string str, const std::string suffix) {
+            const char* p = str.c_str() + str.size();
+            const char* q = suffix.c_str() + suffix.size();
+            for(size_t i = 0; i < suffix.size(); i ++ ) {
+                if (*(p -i - 1) != *(q -i -1)) return false;
+            }
+            return true;
+        }
+
+        static std::string lstrip(const std::string str) {
+            size_t pos = 0;
+            while(pos < str.size() && std::isspace(str[pos])) pos ++;
+            return std::string(str, pos, str.size() - pos);
+        }
+
+        static std::string rstrip(const std::string str) {
+            int pos = str.size() - 1;
+            while(pos >= 0 && std::isspace(str[pos])) pos --;
+            return std::string(str, 0, pos + 1);
+        }
+
+        static std::string strip(const std::string str) {
+            return rstrip(lstrip(str));
+        }
+
+        VarString() {
+            MALLOC(char, _p, BUFSIZE);
+            _cur = _p;
+            _capacity = BUFSIZE;
+        }
+        
+        inline VarString& append(char c) {
+            if (_cur - _p == _capacity - 1) {
+                REALLOC(char, _p, _capacity * 2);
+                _cur = _p + _capacity - 1;
+                _capacity *= 2;
+            }
+
+            *_cur++ = c;
+            return *this;
+        }
+
+        inline VarString& drop() {
+            if (_cur != _p) {
+                _cur --;
+            }
+            return *this;
+        }
+
+        inline VarString& drop(unsigned int len) {
+            if (_cur - len < _p) {
+                len = _p - _cur;
+            }
+            _cur -= len;
+            return *this;
+        }
+
+        VarString& append(const char* p) {
+            int len = strlen(p);
+            return append(p, len);
+        }
+
+        VarString& append(const std::string str) {
+            return append(str.c_str());
+        }
+
+        VarString& append(const char* p, const char c) {
+            append(p);
+            append(c);
+            return *this;
+        }
+
+        VarString& append(const std::string str, const char c) {
+            return append(str.c_str(), c);
+        }
+
+        VarString& append(const char* p1, const char c, const char* p2) {
+            append(p1);
+            append(c);
+            append(p2);
+            return *this;
+        }
+
+        VarString& append(const std::string str1, const char c, const std::string str2) {
+            return append(str1.c_str(), c, str2.c_str());
+        }
+
+        VarString& append(const char* p, int n) {
+            if (_cur - _p + n > _capacity - 1) {
+                int cur_size = _cur - _p;
+                int new_length = 0;
+                if (_cur - _p + n < _capacity * 2 - 1) {
+                    new_length = _capacity * 2; 
+                } else {
+                    new_length = cur_size + n + BUFSIZE;
+                }
+
+                REALLOC(char, _p, new_length);
+                _cur = _p + cur_size;
+                _capacity = new_length;
+            }
+            memcpy(_cur, p, n); 
+            _cur += n;
+            return *this;
+        }
+
+        inline std::string toString() {
+            std::string s(_p, _cur - _p);
+            return s;
+        }
+
+        inline void clear() {
+            _cur = _p;
+        }
+
+        inline int size() const { return _cur - _p; }
+
+        ~VarString() {
+            free(_p);
+        }
+    private:
+        char* _p;
+        char* _cur;
+        int _capacity;
+        VarString(const VarString&);
+        VarString operator=(const VarString&);
+};
+
+
+
+}
+
+#endif
diff --git a/include/gdrive/config.hpp b/include/gdrive/config.hpp
index 4726a67..6d73736 100644
--- a/include/gdrive/config.hpp
+++ b/include/gdrive/config.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_CONFIG_HPP__
 #define __GDRIVE_CONFIG_HPP__
 
diff --git a/include/gdrive/credential.hpp b/include/gdrive/credential.hpp
index 8d97429..acc7d3b 100644
--- a/include/gdrive/credential.hpp
+++ b/include/gdrive/credential.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_CREDENTIAL_HPP__
 #define __GDRIVE_CREDENTIAL_HPP__
 
@@ -7,6 +29,7 @@
 #include "gdrive/store.hpp"
 #include "common/all.hpp"
 
+#include <map>
 #include <string>
 
 namespace GDRIVE {
@@ -17,6 +40,8 @@ class Credential {
     CLASS_MAKE_LOGGER
     public:
         Credential(Store* store);
+        Credential(std::map<std::string, std::string> *auth);
+
         inline bool invalid() const { return _invalid; }
         void refresh(std::string at, std::string rt, long te, std::string it = "");
         void dump();
@@ -30,6 +55,7 @@ class Credential {
         bool _invalid;
 
         Store *_store;
+        std::map<std::string, std::string>* authMap;
 
         Credential(const Credential& other);
         Credential& operator=(const Credential& other);
diff --git a/include/gdrive/drive.hpp b/include/gdrive/drive.hpp
index 631f86d..ef20b58 100644
--- a/include/gdrive/drive.hpp
+++ b/include/gdrive/drive.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_DRIVE_HPP__
 #define __GDRIVE_DRIVE_HPP__
 
diff --git a/include/gdrive/error.hpp b/include/gdrive/error.hpp
index b6b7fc0..ee366af 100644
--- a/include/gdrive/error.hpp
+++ b/include/gdrive/error.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_ERROR_HPP__
 #define __GDRIVE_ERROR_HPP__
 
diff --git a/include/gdrive/filecontent.hpp b/include/gdrive/filecontent.hpp
index d667463..8e45c15 100644
--- a/include/gdrive/filecontent.hpp
+++ b/include/gdrive/filecontent.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_FILECONTENT_HPP__
 #define __GDRIVE_FILECONTENT_HPP__
 
diff --git a/include/gdrive/gdrive.hpp b/include/gdrive/gdrive.hpp
index 627b70c..57ad5d0 100644
--- a/include/gdrive/gdrive.hpp
+++ b/include/gdrive/gdrive.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_GDRIVE_HPP__
 #define __GDRIVE_GDRIVE_HPP__
 
diff --git a/include/gdrive/gitem.hpp b/include/gdrive/gitem.hpp
index cc69fc4..deca90b 100644
--- a/include/gdrive/gitem.hpp
+++ b/include/gdrive/gitem.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_GFILE_HPP__
 #define __GDRIVE_GFILE_HPP__
 
diff --git a/include/gdrive/oauth.hpp b/include/gdrive/oauth.hpp
index bd139f7..4c98a53 100644
--- a/include/gdrive/oauth.hpp
+++ b/include/gdrive/oauth.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_OAUTH_HPP__
 #define __GDRIVE_OAUTH_HPP__
 
diff --git a/include/gdrive/request.hpp b/include/gdrive/request.hpp
index 1685e0a..2a5a8f2 100644
--- a/include/gdrive/request.hpp
+++ b/include/gdrive/request.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_REQUEST_HPP__
 #define __GDRIVE_REQUEST_HPP__
 
diff --git a/include/gdrive/service/about.hpp b/include/gdrive/service/about.hpp
index 94d5b4f..fc55c80 100644
--- a/include/gdrive/service/about.hpp
+++ b/include/gdrive/service/about.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_ABOUTSERVICE_HPP__
 #define __GDRIVE_ABOUTSERVICE_HPP__
 
diff --git a/include/gdrive/service/apps.hpp b/include/gdrive/service/apps.hpp
index b335d3a..7e49c61 100644
--- a/include/gdrive/service/apps.hpp
+++ b/include/gdrive/service/apps.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_APPSERVICE_HPP__
 #define __GDRIVE_APPSERVICE_HPP__
 
diff --git a/include/gdrive/service/changes.hpp b/include/gdrive/service/changes.hpp
index 5940f01..0ab54b2 100644
--- a/include/gdrive/service/changes.hpp
+++ b/include/gdrive/service/changes.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_CHANGESERVICE_HPP__
 #define __GDRIVE_CHANGESERVICE_HPP__
 
diff --git a/include/gdrive/service/children.hpp b/include/gdrive/service/children.hpp
index 342cd66..a732d7c 100644
--- a/include/gdrive/service/children.hpp
+++ b/include/gdrive/service/children.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_CHILDRENSERVICE_HPP__
 #define __GDRIVE_CHILDRENSERVICE_HPP__
 
diff --git a/include/gdrive/service/comments.hpp b/include/gdrive/service/comments.hpp
index 7e8e855..b14ef75 100644
--- a/include/gdrive/service/comments.hpp
+++ b/include/gdrive/service/comments.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_COMMENTSERVICE_HPP__
 #define __GDRIVE_COMMENTSERVICE_HPP__
 
diff --git a/include/gdrive/service/files.hpp b/include/gdrive/service/files.hpp
index 324ca76..2c4d106 100644
--- a/include/gdrive/service/files.hpp
+++ b/include/gdrive/service/files.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_FILESERVICE_HPP__
 #define __GDRIVE_FILESERVICE_HPP__
 
diff --git a/include/gdrive/service/parents.hpp b/include/gdrive/service/parents.hpp
index d4724a0..352ad62 100644
--- a/include/gdrive/service/parents.hpp
+++ b/include/gdrive/service/parents.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_PARENTSERVICE_HPP__
 #define __GDRIVE_PARENTSERVICE_HPP__
 
diff --git a/include/gdrive/service/permissions.hpp b/include/gdrive/service/permissions.hpp
index 589b78d..2134ce4 100644
--- a/include/gdrive/service/permissions.hpp
+++ b/include/gdrive/service/permissions.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_PERMISSIONSERVICE_HPP__
 #define __GDRIVE_PERMISSIONSERVICE_HPP__
 
diff --git a/include/gdrive/service/replies.hpp b/include/gdrive/service/replies.hpp
index 88c7474..5a6f0f8 100644
--- a/include/gdrive/service/replies.hpp
+++ b/include/gdrive/service/replies.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_REPLYSERVICE_HPP__
 #define __GDRIVE_REPLYSERVICE_HPP__
 
diff --git a/include/gdrive/service/revisions.hpp b/include/gdrive/service/revisions.hpp
index 7a3e406..8775d66 100644
--- a/include/gdrive/service/revisions.hpp
+++ b/include/gdrive/service/revisions.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_REVISIONSERVICE_HPP__
 #define __GDRIVE_REVISIONSERVICE_HPP__
 
diff --git a/include/gdrive/servicerequest.hpp b/include/gdrive/servicerequest.hpp
index ce5d96e..e960bee 100644
--- a/include/gdrive/servicerequest.hpp
+++ b/include/gdrive/servicerequest.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_SERVICEREQUEST_HPP__
 #define __GDRIVE_SERVICEREQUEST_HPP__
 
diff --git a/include/gdrive/store.hpp b/include/gdrive/store.hpp
index 210ec15..d52dd73 100644
--- a/include/gdrive/store.hpp
+++ b/include/gdrive/store.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_STORE_HPP__
 #define __GDRIVE_STORE_HPP__
 
diff --git a/include/gdrive/util.hpp b/include/gdrive/util.hpp
index b25faa4..740bd2a 100644
--- a/include/gdrive/util.hpp
+++ b/include/gdrive/util.hpp
@@ -1,3 +1,25 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
 #ifndef __GDRIVE_UTIL_HPP__
 #define __GDRIVE_UTIL_HPP__
 #include <string>
diff --git a/include/jconer/allocator.hpp b/include/jconer/allocator.hpp
new file mode 100644
index 0000000..aba9a03
--- /dev/null
+++ b/include/jconer/allocator.hpp
@@ -0,0 +1,48 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __ALLOCATOR_HPP__
+#define __ALLOCATOR_HPP__
+#include <stdio.h>
+#include "jconer/arena.hpp"
+
+class Allocator {
+  public:
+    Allocator() {
+      arena_ =  arena_New();
+      /*if (arena_ == NULL) {
+        throw std::bad_alloc();
+      }*/
+    }
+    virtual ~Allocator() {
+      arena_Free(arena_);
+    }
+
+    void * malloc(size_t size) {
+      return arena_Malloc(arena_, size);
+    }
+  private:
+    Arena* arena_;
+};
+
+void* allocate(size_t size) /*throw (std::bad_alloc)*/;
+#endif
diff --git a/include/jconer/arena.hpp b/include/jconer/arena.hpp
new file mode 100644
index 0000000..25d37e4
--- /dev/null
+++ b/include/jconer/arena.hpp
@@ -0,0 +1,32 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __PYARENA_H__
+#define __PYARENA_H__
+
+typedef struct _arena Arena;
+
+Arena * arena_New(void);
+void arena_Free(Arena *);
+
+void* arena_Malloc(Arena *, size_t size);
+#endif /* !Py_PYARENA_H */
diff --git a/include/jconer/dump.hpp b/include/jconer/dump.hpp
new file mode 100644
index 0000000..4a3d869
--- /dev/null
+++ b/include/jconer/dump.hpp
@@ -0,0 +1,49 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_DUMP_HPP__
+#define __JCONER_DUMP_HPP__
+
+#include "jconer/token.hpp"
+#include "jconer/value.hpp"
+#include "jconer/stream.hpp"
+#include "jconer/parser.hpp"
+
+#include <iostream>
+
+#define DUMP_SORT_KEY 0x01
+#define DUMP_PRETTY_PRINT 0x02
+#define DUMP_ENSURE_ASCII 0x04
+#define DUMP_COMPACT_PRINT 0x08
+
+#define DUMP_INDENT 4
+
+namespace JCONER {
+
+void dump(JValue* value, std::ostream& out, int flag = DUMP_ENSURE_ASCII);
+void dumpFile(JValue* value, std::string filename, int flag = DUMP_ENSURE_ASCII);
+std::string dumps(JValue* value, int flag = DUMP_ENSURE_ASCII);
+void dumps(JValue* value, char** pbuffer, int flag = DUMP_ENSURE_ASCII);
+
+}
+
+#endif
diff --git a/include/jconer/error.hpp b/include/jconer/error.hpp
new file mode 100644
index 0000000..a948760
--- /dev/null
+++ b/include/jconer/error.hpp
@@ -0,0 +1,101 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_ERROR_HPP__
+#define __JCONER_ERROR_HPP__
+
+#include "jconer/util.hpp"
+#include <stdarg.h>
+#include <string.h>
+#include <stdio.h>
+
+#define BUFSIZE 1024
+
+namespace JCONER {
+enum ErrorType {
+    ET_SUC = 0,
+    ET_IO_FILE_NOT_FOUND,
+    ET_IO_STREAM_NOT_FOUND,
+    ET_IO_READ,
+    ET_PARSE_EOF,
+    ET_PARSE_INVALID_CHAR,
+    ET_PARSE_INVALID_UNICODE,
+    ET_PARSE_INVALID_TOKEN,
+    ET_PARSE_RANGE,
+    ET_PARSE_UNEXPECTED_TOKEN,
+};
+
+struct PError {
+    PError()
+        :lineno(-1), col(-1),
+         type(ET_SUC)
+    {}
+    PError(int lineno_, int col_, std::string text_, ErrorType type_)
+        :lineno(lineno_),
+         col(col_),
+         text(text_),
+         type(type_)
+    {}
+    PError(const PError& other)
+        :lineno(other.lineno),
+         col(other.col),
+         text(other.text),
+         type(other.type)
+    {}
+
+    void setErrorDetail(int lineno_, int col_, ErrorType type_, const char* fmt, ...) {
+        lineno = lineno_;
+        col = col_;
+        type = type_;
+        
+        va_list va;
+        va_start(va, fmt);
+        char fullstr[BUFSIZE];
+        vsnprintf(fullstr, BUFSIZE, fmt, va);
+        va_end(va);
+        text = std::string(fullstr);
+    }
+
+    void setErrorText(const char* fmt, ...) {
+        va_list va;
+        va_start(va, fmt);
+        char fullstr[BUFSIZE];
+        vsnprintf(fullstr, BUFSIZE, fmt, va);
+        va_end(va);
+        text = std::string(fullstr);
+    }
+
+    inline void clear() {
+        lineno = -1;
+        col = -1;
+        text = "";
+        type = ET_SUC;
+    }
+
+    int lineno;
+    int col;
+    std::string text;
+    ErrorType type;
+};
+
+}
+#endif
diff --git a/include/jconer/json.hpp b/include/jconer/json.hpp
new file mode 100644
index 0000000..b61d29e
--- /dev/null
+++ b/include/jconer/json.hpp
@@ -0,0 +1,34 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_JSON_HPP__
+#define __JCONER_JSON_HPP__
+
+#include "jconer/token.hpp"
+#include "jconer/value.hpp"
+#include "jconer/stream.hpp"
+#include "jconer/parser.hpp"
+#include "jconer/dump.hpp"
+#include "jconer/error.hpp"
+#include "jconer/serializer.hpp"
+
+#endif
diff --git a/include/jconer/parser.hpp b/include/jconer/parser.hpp
new file mode 100644
index 0000000..9148ac6
--- /dev/null
+++ b/include/jconer/parser.hpp
@@ -0,0 +1,69 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_PARSER_HPP__
+#define __JCONER_PARSER_HPP__
+
+#include "jconer/token.hpp"
+#include "jconer/value.hpp"
+#include "jconer/stream.hpp"
+#include "jconer/error.hpp"
+#include "common/logging.hpp"
+
+namespace JCONER {
+
+class Parser {
+    public:
+        Parser();
+        Parser(IStream& instream);
+        
+        JValue* parse();
+        JValue* parse(IStream& instream);
+        JValue* parseFromFile(std::string filename);
+        inline PError error() const { return _err;}
+    private:
+        IStream* _instream;
+        Token _cur_token;
+        PError _err;
+ 
+        void _getNextToken();
+        JValue* _parseValue();
+        JValue* _parseInt();
+        JValue* _parseString();
+        JValue* _parseReal();
+        JValue* _parseTrue();
+        JValue* _parseFalse();
+        JValue* _parseNull();
+        JValue* _parseArray();
+        JValue* _parseObject();
+
+        inline bool _checkTokenType(TokenType type) const { return _cur_token.type() == type;}
+};
+
+JValue* load(std::string filename, PError& err);
+JValue* load(const char* filename, PError& err);
+JValue* loads(const char* buffer, PError& err);
+JValue* loads(std::string buffer, PError& err);
+
+}
+
+#endif
diff --git a/include/jconer/serializer.hpp b/include/jconer/serializer.hpp
new file mode 100644
index 0000000..3f7bfb4
--- /dev/null
+++ b/include/jconer/serializer.hpp
@@ -0,0 +1,294 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_OBJECT_HPP__
+#define __JCONER_OBJECT_HPP__
+
+#include "jconer/value.hpp"
+#include <map>
+#include <set>
+#include <list>
+#include <vector>
+#include <cassert>
+
+namespace JCONER {
+
+
+class SerializeFailException : public std::exception {
+  public:
+    const char* what() const throw() {
+      return "Serialize Failed";
+    }
+};
+
+class OutSerializer {
+    public:
+        OutSerializer() {
+            clear(); 
+        }
+
+        JValue* getContent() { return _array; }
+
+        std::string getText() {
+            std::string jsonText = dumps(_array);
+            return jsonText;
+        }
+
+        void clear() {
+          _array = new JArray();
+          _curr = _array;
+        }
+
+        template<class Type>
+        void operator&(Type& value) {
+            JArray* item = new JArray();
+            JArray* old_curr = _curr;
+            _curr->append(item);
+            _curr = item;
+
+            value.serialize(*this);
+            _curr = old_curr;
+        }
+
+        template<template<class T, class Allocator> class Container, class ValueType>
+        void operator&(Container<ValueType, std::allocator<ValueType> >& value) {
+            JArray* item = new JArray();
+            JArray* old_curr = _curr;
+            _curr->append(item);
+            _curr = item;
+
+            for(typename Container<ValueType, std::allocator<ValueType> >::iterator iter = value.begin();
+                    iter != value.end(); iter ++) {
+                *this & *iter;
+            }
+            _curr = old_curr;
+        }
+
+        template<class K, class V>
+        void operator&(std::pair<K, V>& value) {
+            JArray* item = new JArray();
+            JArray* old_curr = _curr;
+            _curr->append(item);
+            _curr = item;
+
+            *this & value.first;
+            *this & value.second;
+            _curr = old_curr;
+        }
+
+        template<class K, class V>
+        void operator&(std::map<K,V>& value) {
+            JArray* item = new JArray();
+            JArray* old_curr = _curr;
+            _curr->append(item);
+            _curr = item;
+
+            for(typename std::map<K, V>::iterator iter = value.begin();
+                    iter != value.end(); iter ++) {
+                *this & *iter;
+            }
+            _curr = old_curr;
+        }
+
+        void operator&(const int value) {
+            _curr->append(value);
+        }
+
+        void operator&(const long value) {
+            _curr->append(value);
+        }
+
+        void operator&(const std::string value) {
+            _curr->append(value);
+        }
+
+        void operator&(const bool value) {
+            _curr->append(value);
+        }
+
+        void operator&(const char* value) {
+            _curr->append(value);
+        }
+
+        void operator&(const double value) {
+            _curr->append(value);
+        }
+
+        void operator&(const float value) {
+            _curr->append(value);
+        }
+
+
+    private:
+        JArray* _array;
+        JArray* _curr;
+};
+
+
+class InSerializer {
+    public:
+        InSerializer(JValue* array) {
+            assert(array->isArray());
+            _array = (JArray*)array;
+            _curr = _array;
+            _index = 0;
+        }
+
+        InSerializer(std::string jsonText) {
+          PError err;
+          JValue * array = loads(jsonText, err);
+          assert(array != NULL && array->isArray());
+
+          _array = (JArray*)array;
+          _curr = _array;
+          _index = 0;
+        }
+
+        template<class Type>
+        void operator&(Type& value) {
+            _check();
+            JArray* old_curr = _curr;
+            _curr = (JArray*)_curr->get(_index);
+
+            int old_index = _index;
+            _index = 0;
+            
+            value.serialize(*this);
+
+            _curr = old_curr;
+            _index = old_index + 1;
+        }
+
+        template<template<class T, class Allocator> class Container, class ValueType>
+        void operator&(Container<ValueType, std::allocator<ValueType> >& value) {
+            _check();
+            value.clear();
+            JArray* old_curr  = _curr;
+            _curr = (JArray*)_curr->get(_index);
+
+            int old_index = _index;
+            _index = 0;
+
+            for(int i = 0; i < _curr->size(); i ++) {
+                ValueType tmp;
+                value.push_back(tmp);
+            }
+
+            for(typename Container<ValueType, std::allocator<ValueType> >::iterator iter = value.begin();
+                    iter != value.end(); iter ++) {
+                *this & *iter;
+            }
+            _curr = old_curr;
+            _index = old_index + 1;
+        }
+
+        template<class K, class V>
+        void operator&(std::pair<K, V>& value) {
+            _check();
+            JArray* old_curr  = _curr;
+            _curr = (JArray*)_curr->get(_index);
+
+            int old_index = _index;
+            _index = 0;
+
+            *this & value.first;
+            *this & value.second;
+
+            _curr = old_curr;
+            _index = old_index + 1;
+
+        }
+
+        template<class K, class V>
+        void operator&(std::map<K,V>& value) {
+            _check();
+            value.clear();
+            JArray* old_curr  = _curr;
+            _curr = (JArray*)_curr->get(_index);
+
+            int old_index = _index;
+            _index = 0;
+
+            for(int i = 0; i < _curr->size(); i ++) {
+                K k;
+                V v;
+                std::pair<K, V> p = std::make_pair(k, v);
+                *this & p;
+                value.insert(p);
+            }
+
+            _curr = old_curr;
+            _index = old_index + 1;
+        }
+
+
+        void operator&(int& value) {
+            _check();
+            value = _curr->get(_index)->getInteger();
+            _index ++;
+        }
+
+        void operator&(long& value) {
+            _check();
+            value = _curr->get(_index)->getInteger();
+            _index ++;
+        }
+
+        void operator&(std::string& value) {
+            _check();
+            value = _curr->get(_index)->getString();
+            _index ++;
+        }
+
+        void operator&(bool& value) {
+            _check();
+            if (_curr->get(_index)->isTrue())
+                value = true;
+            else
+                value = false;
+            _index ++;
+        }
+
+        void operator&(double& value) {
+            _check();
+            value = _curr->get(_index)->getReal();
+            _index ++;
+        }
+
+        void operator&(float& value) {
+            _check();
+            value = _curr->get(_index)->getReal();
+            _index ++;
+        }
+    private:
+        JArray* _array;
+        JArray* _curr;
+        int _index;
+
+        inline void _check() {
+          if (_index >= _curr->size()) {
+            throw SerializeFailException();
+          }
+        }
+};
+}
+#endif
diff --git a/include/jconer/stream.hpp b/include/jconer/stream.hpp
new file mode 100644
index 0000000..fddfd8a
--- /dev/null
+++ b/include/jconer/stream.hpp
@@ -0,0 +1,64 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_STREAM_HPP__
+#define __JCONER_STREAM_HPP__
+
+#include "jconer/token.hpp"
+#include "common/logging.hpp"
+#include "jconer/error.hpp"
+
+#include <istream>
+#include <fstream>
+
+
+namespace JCONER {
+
+class IStream {
+    public:
+        IStream(std::istream& _fin);
+        virtual Token getNextToken();
+        inline PError error() const { return _err; }
+        virtual ~IStream();
+    private:
+        int _getLength();
+        int _getRemainingLength();
+
+        int _getNextChar();
+        void _ungetChar();
+        bool _stripWhitespace();
+        int _readBuffer();
+        int _getNChar(char* str, int n);
+
+        std::istream& _fin;
+        int _lineno;
+        int _col;
+        char* _buff;
+        char* _end;
+        char* _cur;
+        int _cur_pos;
+        int _content_length;
+        PError _err;
+};
+
+}
+#endif
diff --git a/include/jconer/token.hpp b/include/jconer/token.hpp
new file mode 100644
index 0000000..e8f86ef
--- /dev/null
+++ b/include/jconer/token.hpp
@@ -0,0 +1,91 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_TOKEN_HPP__
+#define __JCONER_TOKEN_HPP__
+
+#include <string>
+#include "common/all.hpp"
+using namespace COMMON;
+
+namespace JCONER {
+
+enum TokenType {
+    TT_ARRAY_OPEN_BRACE = 0,
+    TT_ARRAY_CLOSE_BRACE,
+    TT_OBJECT_OPEN_BRACE,
+    TT_OBJECT_CLOSE_BRACE,
+
+    TT_COMMA,
+    TT_COLON,
+
+    TT_STRING,
+    TT_INTEGER,
+    TT_REAL,
+
+    TT_TRUE,
+    TT_FALSE,
+    TT_NULL,
+
+    TT_END, // end of file
+
+    TT_INVALID
+};
+
+class Token {
+    public:
+        Token(TokenType type)
+            :_type(type), _lineno(-1), _col(-1)
+        {
+        }
+        Token(TokenType type, int lineno, int col, std::string text)
+            : _type(type), _lineno(lineno), _col(col), _text(text)
+        {
+            LOG(DEBUG) << "Generate a new token[" << toString() << "] at [" << _lineno << "|" << _col << "]" << std::endl;
+        }
+        Token(TokenType type, int lineno, int col, char c)
+            : _type(type), _lineno(lineno), _col(col), _text(1, c)
+        {
+            LOG(DEBUG) << "Generate a new token[" << toString() << "] at [" << _lineno << "|" << _col << "]" << std::endl;
+        }
+
+        Token(const Token& t)
+            : _type(t._type), _lineno(t._lineno), _col(t._col), _text(t._text)
+        {
+        }
+
+        inline TokenType type() const { return _type; }
+        inline int lineno() const { return _lineno; }
+        inline int col() const { return _col;}
+        inline std::string text() const { return _text; }
+        static TokenType getTokenOne(char c);
+        std::string toString();
+    private:
+        TokenType _type;
+        int _lineno;
+        int _col;
+        std::string _text;
+};
+
+
+}
+#endif
diff --git a/include/jconer/util.hpp b/include/jconer/util.hpp
new file mode 100644
index 0000000..ff7f3df
--- /dev/null
+++ b/include/jconer/util.hpp
@@ -0,0 +1,131 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_UTIL_HPP__
+#define __JCONER_UTIL_HPP__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <string>
+
+namespace JCONER {
+
+class HexCode {
+    public:
+        static int32_t decode(const char* str) {
+            int32_t value = 0;
+            for(int i = 0; i < 4; i ++ ) {
+                value <<= 4;
+                char c = str[i];
+                if (isdigit(c)){
+                    value += c - '0';
+                } else if ('A' <= c && c <= 'F') { 
+                    value += c - 'A' + 10;
+                } else if ('a' <=c && c <= 'f') {
+                    value += c - 'a' + 10;
+                } else {
+                    return -1;
+                }
+            }
+            return value;
+        }
+};
+
+class UTF8 {
+    public:
+        static int encode(int32_t value, char* str, int n) {
+            if (value < 0 || n <= 0)
+                return -1;
+            if (value < 0x80) {
+                str[0] = (char)value;
+                return 1;
+            }
+            if (value < 0x800) {
+                if (n < 2) return -1;
+                str[0] = 0xC0 + ((value & 0x7C0) >> 6);
+                str[1] = 0x80 + ((value & 0x03F));
+                return 2;
+            }
+            if (value < 0x10000) {
+                if (n < 3) return -1;
+                str[0] = 0xE0 + ((value & 0XF000) >> 12);
+                str[1] = 0x80 + ((value & 0x0FC0) >> 6);
+                str[2] = 0x80 + ((value & 0x003F));
+                return 3;
+            }
+            if (value <= 0x10FFFF) {
+                if (n < 4) return -1;
+                str[0] = 0xF0 + ((value & 0x1C0000) >> 18);
+                str[1] = 0x80 + ((value & 0x03F000) >> 12);
+                str[2] = 0x80 + ((value & 0x000FC0) >> 6);
+                str[3] = 0x80 + ((value & 0x00003F));
+                return 4;
+            }
+            return -1;
+        }
+    
+        static int decode(const char* p, int32_t* hex) {
+            int count = getUTF8Length(p);
+            if (count  == 0) {
+                return 0;
+            }
+            if (count == 1) {
+                *hex = (int32_t)*p;
+            } else {
+                int32_t value = 0;
+                unsigned char u = (unsigned char)*p;
+
+                if (count == 2) value = u & 0x1F;
+                else if (count == 3) value = u & 0xF;
+                else value = u & 0x7;
+
+                for (int i = 1; i < count; i ++ ) {
+                    u = (unsigned char)p[i];
+                    if (u < 0x80 || u > 0xBF) return 0;
+                    value = (value << 6) + (u & 0x3F);
+                }
+
+                if (value > 0x10FFFF) return 0;
+                if (0xD800 <= value && value <= 0xDFFF) return 0;        
+                if ((count == 2 && value < 0x80) ||
+                    (count == 3 && value < 0x800) ||
+                    (count == 4 && value < 0x10000)) return 0;
+                *hex = value;
+            }
+            return count;
+        }
+    private:
+        static int getUTF8Length(const char* p) {
+            unsigned char byte = (unsigned char)*p;
+            if (byte < 0x80) return 1;
+            if (0x80 <= byte && byte <= 0xBF) return 0;
+            if (byte == 0xC0 || byte == 0xC1) return 0;
+            if (0xC2 <= byte && byte <= 0xDF) return 2;
+            if (0xE0 <= byte && byte <= 0xEF) return 3;
+            if (0xF0 <= byte && byte <= 0xF4) return 4;
+            return 0;
+        }
+};
+
+}
+#endif
diff --git a/include/jconer/value.hpp b/include/jconer/value.hpp
new file mode 100644
index 0000000..d69f260
--- /dev/null
+++ b/include/jconer/value.hpp
@@ -0,0 +1,254 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_VALUE_HPP__
+#define __JCONER_VALUE_HPP__
+
+#include <string>
+#include <map>
+#include <vector>
+#include "jconer/allocator.hpp"
+
+#include "common/logging.hpp"
+#define NULL_VALUE 0
+
+namespace JCONER {
+
+typedef int NULL_TYPE;
+
+enum ValueType {
+    VT_OBJECT = 0,
+    VT_ARRAY,
+    VT_INTEGER,
+    VT_STRING,
+    VT_REAL,
+    VT_TRUE,
+    VT_FALSE,
+    VT_NULL
+};
+
+enum InsertError {
+    IE_SUC = 0,
+    IE_SELF,
+    IE_NULL
+};
+
+class JValue {
+    public:
+        JValue(ValueType type);
+        inline ValueType type() { return _type; }
+        virtual ~JValue();
+        virtual JValue* deepcopy() = 0;
+        virtual void printout() = 0;
+
+        static inline bool isString(const JValue* value) { return value->_type == VT_STRING;}
+        static inline bool isInteger(const JValue* value) { return value->_type == VT_INTEGER;}
+        static inline bool isReal(const JValue* value) { return value->_type == VT_REAL;}
+        static inline bool isTrue(const JValue* value) { return value->_type == VT_TRUE;}
+        static inline bool isFalse(const JValue* value) { return value->_type == VT_FALSE;}
+        static inline bool isNull(const JValue* value) { return value->_type == VT_NULL;}
+        static inline bool isObject(const JValue* value) { return value->_type == VT_OBJECT;}
+        static inline bool isArray(const JValue* value) { return value->_type == VT_ARRAY;}
+
+        inline bool isString() { return _type == VT_STRING; }
+        inline bool isInteger() { return _type == VT_INTEGER; }
+        inline bool isReal() { return _type == VT_REAL; }
+        inline bool isTrue() { return _type == VT_TRUE; }
+        inline bool isFalse() { return _type == VT_FALSE; }
+        inline bool isNull() { return _type == VT_NULL;}
+        inline bool isObject() { return _type == VT_OBJECT; }
+        inline bool isArray() { return _type == VT_ARRAY; }
+
+        std::string getString();
+        long getInteger();
+        bool getBool();
+        double getReal();
+
+        JValue* get(size_t i);
+        JValue* get(std::string key);
+        int size();
+        std::vector<std::string> getKeys();
+        bool contain(std::string key);
+#if false
+        void* operator new(size_t size) throw (std::bad_alloc) {
+            return allocate(size);
+        }
+
+        void operator delete(void* ptr) throw () {            
+        }
+#endif
+
+    protected:
+        ValueType _type;
+};
+
+class JNull : public  JValue {
+    public:
+        static JNull* getInstance() {
+            return &_instance;
+        }
+        inline NULL_TYPE getValue() { return NULL_VALUE; }
+        void printout();
+        JValue* deepcopy();
+    private:
+        JNull();
+        static JNull _instance;
+};
+
+class JInt : public JValue {
+    public:
+        JInt(const long value);
+        inline long getValue() { return _value; }
+        void printout();
+        JValue* deepcopy();
+    private:
+        long _value;
+};
+
+class JReal : public JValue {
+    public:
+        JReal(const double value);
+        inline double getValue() { return _value; }
+        void printout();
+        JValue* deepcopy();
+    private:
+        double _value;
+};
+
+class JString : public JValue {
+    public:
+        JString(const std::string value);
+        JString(const char* str);
+        inline std::string getValue() { return _value; }
+        std::string getAsciiValue();
+        void printout();
+        JValue* deepcopy();
+    private:
+        std::string _value;
+};
+
+class JTrue : public JValue {
+    public:
+        static JTrue* getInstance() {
+            return &_instance;
+        }
+        inline bool getValue() { return true; }
+        void printout();
+        JValue* deepcopy();
+        JTrue();
+    private:
+        //JTrue();
+        static JTrue _instance;
+};
+
+class JFalse : public JValue {
+    public:
+        static JFalse* getInstance() {
+            return &_instance;
+        }
+        inline bool getValue() { return true; }
+        void printout();
+        JValue* deepcopy();
+        JFalse();
+    private:
+        //JFalse();
+        static JFalse _instance;
+};
+
+class JArray : public JValue {
+    public:
+        JArray();
+        JArray(const std::vector<JValue*>& array);
+        ~JArray();
+
+        inline std::vector<JValue*> getArray() { return _array; }
+        inline int size() { return _array.size(); }
+        void printout();
+        inline JValue* get(size_t i) {
+            if (i < _array.size())
+                return _array[i];
+            else
+                return NULL;
+        }
+
+        InsertError append(JValue* element);
+        void append(const long value);
+        void append(const size_t value);
+        void append(const int value);
+        void append(const std::string value);
+        void append(const char* str);
+        void append(const bool value);
+        void append(const double value);
+        void appendNull();
+
+        JValue* pop_back();
+        JValue* pop(size_t i);
+        JValue* deepcopy();
+    private:
+        std::vector<JValue*> _array;
+};
+
+class JObject : public JValue {
+    public:
+        JObject();
+        JObject(const std::map<std::string, JValue*>& object);
+        ~JObject();
+
+        inline std::map<std::string, JValue*> getObject() { return _object; }
+        inline int size() { return _object.size(); }
+        void printout();
+        inline bool contain(std::string key) {
+            if (_object.find(key) != _object.end()) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        inline JValue* get(std::string key) {
+            if (_object.find(key) != _object.end()) {
+                return _object[key];
+            } else {
+                return NULL;
+            }
+        }
+
+        std::vector<std::string> getKeys();
+
+        InsertError put(const std::string, JValue*); 
+        void put(const std::string, const long);
+        void put(const std::string, const size_t);
+        void put(const std::string, const int);
+        void put(const std::string, const std::string);
+        void put(const std::string, const char*);
+        void put(const std::string, const bool);
+        void put(const std::string, const double);
+        void put(const std::string);
+        JValue* pop(std::string key);
+        JValue* deepcopy();
+    private:
+        std::map<std::string, JValue*> _object;
+};
+
+}
+
+#endif
diff --git a/libjconer/.gitignore b/libjconer/.gitignore
new file mode 100755
index 0000000..0def275
--- /dev/null
+++ b/libjconer/.gitignore
@@ -0,0 +1,21 @@
+# Compiled Object files
+*.slo
+*.lo
+*.o
+*.obj
+
+# Compiled Dynamic libraries
+*.so
+*.dylib
+*.dll
+
+# Compiled Static libraries
+*.lai
+*.la
+*.a
+*.lib
+
+# Executables
+*.exe
+*.out
+*.app
diff --git a/libjconer/.travis.yml b/libjconer/.travis.yml
new file mode 100755
index 0000000..af723c9
--- /dev/null
+++ b/libjconer/.travis.yml
@@ -0,0 +1,11 @@
+language: cpp
+compiler:
+  - gcc
+  - clang
+  - g++
+
+before_script:
+    - cd ../
+    - git clone git://github.com/allenbo/common.git
+    - cd JConer && cp -R ../common/include/common include
+script: make
diff --git a/libjconer/LICENSE b/libjconer/LICENSE
new file mode 100755
index 0000000..8f8e994
--- /dev/null
+++ b/libjconer/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2014 Justin (Jianfeng) Lin
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
\ No newline at end of file
diff --git a/libjconer/Makefile b/libjconer/Makefile
new file mode 100755
index 0000000..ad48c4a
--- /dev/null
+++ b/libjconer/Makefile
@@ -0,0 +1,44 @@
+SRC_DIR := ./src
+TEST_SRC_DIR := ./test
+INCLUDE_DIR := ./include
+BUILD_DIR := ./build
+TESTBIN_DIR := $(BUILD_DIR)/test
+
+CPP := ${CXX}
+CC := ${CC}
+AR := ${AR}
+
+CFLAG := -O2 -Wall -std=c++11 ${CXXFLAGS}
+LFLAG := -O2 -flto -lpthread
+ARFLAG := -rcs
+
+SRC := $(wildcard $(SRC_DIR)/*.cpp)
+OBJ := $(patsubst %.cpp,%.o, $(subst $(SRC_DIR),$(BUILD_DIR), $(SRC)))
+TEST_SRC := $(wildcard $(TEST_SRC_DIR)/*.cpp)
+TEST_TARGET := $(patsubst %.cpp, %, $(subst $(TEST_SRC_DIR),$(TESTBIN_DIR), $(TEST_SRC)))
+
+ARCHIVE := libjconer.a
+
+.PHONY:all target test $(BUILD_DIR) $(TESTBIN_DIR)
+all: test target
+test: $(TESTBIN_DIR) $(TEST_TARGET) target
+target: $(BUILD_DIR) $(OBJ) $(ARCHIVE)
+
+$(BUILD_DIR):
+	mkdir -p $@
+
+$(BUILD_DIR)/%.o:$(SRC_DIR)/%.cpp
+	$(CPP) -c $< $(CFLAG) -o $@ -I$(INCLUDE_DIR)
+
+$(ARCHIVE):$(OBJ)
+	$(AR) $(ARFLAG) $@ $(OBJ)
+
+$(TESTBIN_DIR):
+	mkdir -p $@
+
+
+$(TESTBIN_DIR)/%:$(TEST_SRC_DIR)/%.cpp $(OBJ)
+	$(CPP) $^ $(CFLAG) $(LFLAG) -o $@ -I$(INCLUDE_DIR) -L$(BUILD_DIR)
+
+clean:
+	rm -rf $(BUILD_DIR) $(TESTBIN_DIR) $(ARCHIVE)
diff --git a/libjconer/README.md b/libjconer/README.md
new file mode 100755
index 0000000..15c67eb
--- /dev/null
+++ b/libjconer/README.md
@@ -0,0 +1,129 @@
+JConer
+======
+[![Build Status](https://travis-ci.org/allenbo/JConer.svg?branch=master)](https://travis-ci.org/allenbo/JConer)
+
+A C++ implementation for Json
+
+Setup
+-----
+JConer is using the other repository for some common utility of C++ programming, like logger and string operation.
+```
+git clone git@github.com:allenbo/common.git
+git clone git@github.com:allenbo/JConer.git
+cd JConer
+cp -R ../common/include/common include/
+make
+```
+
+Examples
+------
+**Load from file and buffer**
+```
+#include "jconer/json.hpp"
+using namespace JCONER;
+PError err;
+JValue* rst = load("myjsonfile", err);
+err.clear();
+rst = loads("[128, 256]", err);
+```
+
+**dump to file and buffer**
+```
+#include "jconer/json.hpp"
+using namespace JCONER;
+JValue* item = any_function_or_operation_that_returns_a_json_value();
+dump(item, std::cout);
+char* buffer;
+dumps(item, &buffer);
+std::cout << buffer << std::endl;
+free(buffer);
+```
+JCONER VALUES
+------
+```
+JValue: the base class of all other JCONER value
+JInt: type() == VT_INTEGER
+JString: type() == VT_STRING
+JReal: type() == VT_REAL
+JTrue: type() == VT_TRUE
+JFalse: type() == VT_FALSE
+JNull: type() == VT_NULL
+JArrty: type() == VT_ARRAY
+JObject: type() == VT_OBJECT
+```
+Manipulation of array and object
+------
+**JArray**
+```
+JArray * array_item = new JArray();
+array_item.append(int_value);
+array_item.append(string_value);
+array_item.append(bool_value);
+array_item.append(); // append JNull
+array_item.append(real_value);
+array_item.append(other_jvalue_ptr);
+```
+**JObject**
+```
+JObject* obj_item = new JObject();
+obj_item.put("an_integer", int_value);
+obj_item.put("an_string", string_value);
+obj_item.put("an_null");
+obj_item.put("an_jvalue", other_jvalue_ptr);
+```
+Serializer
+------
+JConer provides a convenient serializer to convert user-defined object to JArray. Here is how it works.
+```
+#include "jconer/json.hpp"
+
+class Helper {
+    public:
+        Helper() {
+            _x = _y = 0;
+        }
+
+        template<class Serializer>
+        JArray* serialize(Serializer& serializer) {
+            serializer & _x;
+            serializer & _y;
+        }
+    private:
+        int _x, _y;
+};
+
+class Test {
+    public:
+        template<class Serializer>
+        JArray* serialize(Serializer& serializer) {
+            serializer & _int_value;
+            serializer & _real_value;
+            serializer & _string_value;
+            serializer & _instance_value;
+            serializer & _vector_value;
+            serializer & _primitive_map_value;
+            serializer & _user_defined_map_value;
+        }
+    private:
+        int _int_value;
+        double _real_value;
+        std::string _string_value;
+        Helper _instance_value;
+        std::vector<int> _vector_value;
+        std::map<std::string, int> _primitive_map_value; //key has to be string
+        std::map<std::string, Helper> _user_defined_map_value;
+};
+
+
+int main() {
+    OutSerializer sout;
+    Test test;
+    JArray* rst = sout & test;
+    dump(rst, std::cout, DUMP_PRETTY_PRINT | DUMP_ENSURE_ASCII);
+    Test another_test;
+    InSerializer sin(rst);
+    another_test & sin;
+    assert (another_test == test);
+}
+```
+All you have to do is to define a serialize method for every class you want to serialize.
diff --git a/libjconer/grammer b/libjconer/grammer
new file mode 100755
index 0000000..09ee846
--- /dev/null
+++ b/libjconer/grammer
@@ -0,0 +1,26 @@
+message := value;
+
+value := array |
+         object |
+         primitive;
+
+array := '[' ']' |
+         '[' values ']';
+
+values := value |
+          value ',' values;
+
+object := '{' '}' |
+          '{' pairs '}';
+
+pairs := pair |
+         pair ',' pairs;
+
+pair := string ':' value;
+
+primitive := string |
+             integer |
+             real |
+             true |
+             false |
+             null;
diff --git a/libjconer/include/common/all.hpp b/libjconer/include/common/all.hpp
new file mode 100644
index 0000000..8c7c082
--- /dev/null
+++ b/libjconer/include/common/all.hpp
@@ -0,0 +1,17 @@
+#ifndef __COMMON_ALL_HPP__
+#define __COMMON_ALL_HPP__
+
+#include "common/logging.hpp"
+#include "common/loggingv2.hpp"
+#include "common/varstring.hpp"
+#include "common/threading.hpp"
+#include "common/threadpool.hpp"
+#include "common/queue.hpp"
+#include "common/timer.hpp"
+#include "common/property.hpp"
+#include "common/path.hpp"
+#include "common/misc.hpp"
+
+namespace COMMON = common;
+
+#endif
diff --git a/libjconer/include/common/logging.hpp b/libjconer/include/common/logging.hpp
new file mode 100644
index 0000000..352cded
--- /dev/null
+++ b/libjconer/include/common/logging.hpp
@@ -0,0 +1,138 @@
+#ifndef __common_LOGGING_HPP__
+#define __common_LOGGING_HPP__
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <string>
+
+namespace common {
+
+#define CLASS_MAKE_LOGGER \
+    private:\
+            common::Logger _logger;
+#define CLASS_INIT_LOGGER(classname, level)\
+    _logger.setClassName(classname);\
+    _logger.setLevel(level);
+#define CLOG_DEBUG(...) _logger.debug( __func__, __FILE__, __LINE__, __VA_ARGS__)
+#define CLOG_INFO(...) _logger.info( __func__, __FILE__, __LINE__, __VA_ARGS__)
+#define CLOG_WARN(...) _logger.warn(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+#define CLOG_ERROR(...) _logger.error(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+#define CLOG_FATAL(...) _logger.fatal(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+
+
+#define FUNC_MAKE_LOGGER common::Logger __func_logger__;
+#define FUNC_LOGGER_SET_LEVEL(level) __func_logger__.setLevel(level);
+#define FLOG_DEBUG(...) __func_logger__.debug( __func__, __FILE__, __LINE__, __VA_ARGS__)
+#define FLOG_INFO(...) __func_logger__.info( __func__, __FILE__, __LINE__, __VA_ARGS__)
+#define FLOG_WARN(...) __func_logger__.warn(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+#define FLOG_ERROR(...) __func_logger__.error(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+#define FLOG_FATAL(...) __func_logger__.fatal(  __func__,__FILE__, __LINE__, __VA_ARGS__)
+
+static const char* level_literal[] = {
+    "Debug",
+    "Info",
+    "Warn",
+    "Error",
+    "Fatal",
+    NULL
+};
+
+
+enum Level {
+    L_DEBUG = 0,
+    L_INFO,
+    L_WARN,
+    L_ERROR,
+    L_FATAL
+};
+
+enum LoggerType {
+    LT_CLASS,
+    LT_FUNCTION
+};
+
+class Logger {
+    public:
+        Logger()
+            : _level(L_INFO), _type(LT_FUNCTION) {}
+
+        Logger(Level level)
+            : _level(level), _type(LT_FUNCTION) {}
+
+        void setLevel(Level level) { _level = level; }
+        void setClassName(std::string cname) { _cname = cname; _type = LT_CLASS;}
+
+        void debug(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_DEBUG, fmt, va);
+            va_end(va);
+        }
+
+        void info(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_INFO, fmt, va);
+            va_end(va);
+        }
+
+        void warn(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_WARN, fmt, va);
+            va_end(va);
+        }
+
+        void error(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_ERROR, fmt, va);
+            va_end(va);
+        }
+
+        void fatal(const char* funcname, const char* filename, int lineno, const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            _log(funcname, filename, lineno, L_FATAL, fmt, va);
+            va_end(va);
+        }
+
+    private:
+        Level _level;
+        std::string _cname;
+        LoggerType _type;
+
+        void _log(const char* funcname, const char* filename, int lineno, Level level, const char* fmt, va_list va) {
+            if (level < _level) return;
+            char fullfmt[512];
+            const char* basename = baseFilename(filename);
+            if (_type == LT_FUNCTION) {
+                snprintf(fullfmt, 511, "%s %s @ [%s|%d] %s", level_literal[level], funcname, basename, lineno, fmt);
+            } else {
+                snprintf(fullfmt, 511, "%s %s:%s @ [%s|%d] %s", level_literal[level], _cname.c_str(), funcname, basename, lineno, fmt);
+            }
+            vfprintf(stderr, fullfmt, va);
+
+            if (level == L_ERROR or level == L_FATAL) {
+                fprintf(stderr, "Abort!\n");
+                exit(-1);
+            }
+        }
+
+        const char* baseFilename(const char* path) {
+            const char* p = path + strlen(path);
+            while (p != path) {
+                if (*p == '/') {
+                    return p + 1;
+                }
+                p --;
+            }
+            return path;
+        }
+};
+
+}
+
+#endif
diff --git a/libjconer/include/common/loggingv2.hpp b/libjconer/include/common/loggingv2.hpp
new file mode 100644
index 0000000..3525e4c
--- /dev/null
+++ b/libjconer/include/common/loggingv2.hpp
@@ -0,0 +1,168 @@
+#ifndef __common_LOGGINGV2_HPP__
+#define __common_LOGGINGV2_HPP__
+
+#include <iostream>
+#include <sstream>
+#include <memory>
+#include <cstdlib>
+#include <string.h>
+
+namespace common {
+
+#define LOGGINGV2_NONE 0
+#define LOGGINGV2_DEBUG 1
+#define LOGGINGV2_INFO 2
+#define LOGGINGV2_WARN 3
+#define LOGGINGV2_FATAL 4
+
+#ifdef NONE
+#undef NONE
+#endif
+#define NONE LOGGINGV2_NONE
+
+#ifdef DEBUG
+#undef DEBUG
+#endif
+#define DEBUG LOGGINGV2_DEBUG
+
+#ifdef INFO
+#undef INFO
+#endif
+#define INFO LOGGINGV2_INFO
+
+#ifdef WARN
+#undef WARN
+#endif
+#define WARN LOGGINGV2_WARN
+
+#ifdef FATAL
+#undef FATAL
+#endif
+#define FATAL LOGGINGV2_FATAL
+
+#ifdef NDEBUG
+#define LIMIT LOGGINGV2_INFO
+#else
+#define LIMIT LOGGINGV2_DEBUG
+#endif
+
+#define LOG(severity) COMPACT_LOG_MESSAGE(severity)
+#define COMPACT_LOG_MESSAGE(s) LOG_MESSAGE_ ## s(__FILE__, __LINE__)
+
+#define LOG_MESSAGE_0(file, lineno) common::LogMessage::New(0, file, lineno)
+#define LOG_MESSAGE_1(file, lineno) common::LogMessage::New(1, file, lineno)
+#define LOG_MESSAGE_2(file, lineno) common::LogMessage::New(2, file, lineno)
+#define LOG_MESSAGE_3(file, lineno) common::LogMessage::New(3, file, lineno)
+#define LOG_MESSAGE_4(file, lineno) common::LogMessage::New(4, file, lineno)
+
+#define CHECK_OP(op, x, y)  (((x) op (y))? LOG(NONE) : LOG(FATAL))
+
+#define CHECK_EQ(x, y) CHECK_OP(==, x, y)
+#define CHECK_NE(x, y) CHECK_OP(!=, x, y)
+#define CHECK_GT(x, y) CHECK_OP(>, x, y)
+#define CHECK_GE(x, y) CHECK_OP(>=, x, y)
+#define CHECK_LT(x, y) CHECK_OP(<, x, y)
+#define CHECK_LE(x, y) CHECK_OP(<=, x, y)
+#define CHECK(x) CHECK_EQ(x, true)
+
+#define CHECK_NULL(x) CHECK_OP(==, x, nullptr)
+#define CHECK_NOTNULL(x) CHECK_OP(!=, x, nullptr)
+
+#define LOG_IF(severity, expr) ((expr) ? LOG(severity) : LOG(NONE))
+
+#define LOG_EVERY_N(severity, n) LOG_EVERY_N2(severity, n, __LINE__)
+#define LOG_EVERY_N2(severity, n, line) \
+    static int LOG_OCCURRENCE ## line= 0;\
+    static int LOG_MODULE ## line = (n); \
+    LOG_OCCURRENCE ## line  ++; if (LOG_OCCURRENCE ## line == LOG_MODULE ## line) LOG_OCCURRENCE ## line -= LOG_MODULE ## line; \
+    LOG_IF(severity, LOG_OCCURRENCE ## line == 1)
+
+#define LOG_FIRST_N(severity, n) LOG_FIRST_N2(severity, n, __LINE__) 
+#define LOG_FIRST_N2(severity, n, line) \
+    static int LOG_OCCURRENCE ## line = 0;  \
+    static int LOG_MAX ## line = (n);\
+    LOG_OCCURRENCE ## line ++; \
+    LOG_IF(severity, LOG_OCCURRENCE ## line <= LOG_MAX ## line)
+
+static const char* log_literal[] = {
+    "None",
+    "Debug",
+    "Info",
+    "Warn",
+    "Error",
+    "Fatal",
+    nullptr
+};
+
+class LogMessage {
+    public:
+        LogMessage(int severity, const char* filename, const int lineno) {
+            _severity = severity;
+            _filename = filename;
+            _lineno = lineno;
+            _stream = std::shared_ptr<std::ostringstream>(new std::ostringstream());
+            if (_severity != LOGGINGV2_NONE)
+                (*this) << log_literal[_severity] << " [" << baseFilename(filename) << "|" << lineno << "] ";
+        }
+
+        LogMessage(const LogMessage& other) {
+            _severity = other._severity;
+            _filename = other._filename;
+            _lineno = other._lineno;
+            _stream = other._stream;
+        }
+
+        ~LogMessage() {
+            if (_severity >= LIMIT) {
+              std::cerr << _stream->str();
+            }
+            if (_severity == FATAL) {
+              std::cerr << "Abort" << std::endl;
+              exit(-1);
+            }
+        }
+
+        static LogMessage New(int severity, const char* filename, const int lineno, bool cond = true) {
+            if (cond) {
+              return LogMessage(severity, filename, lineno);
+            } else {
+              return LogMessage(LOGGINGV2_NONE, filename, lineno);
+            }
+        }
+
+        template<class T>
+        LogMessage& operator<<(const T& t) {
+            if (_severity >= LIMIT)
+                (*_stream) << t;
+            return *this;
+        }
+
+        typedef std::basic_ostream<char, std::char_traits<char> > CoutType;
+        typedef CoutType& (*StandardEndLine)(CoutType&);
+
+        LogMessage& operator<<(StandardEndLine manip) {
+            if (_severity >= LIMIT)
+                manip(*_stream);
+            return *this;
+        }
+    private:
+        int _severity;
+        const char* _filename;
+        int _lineno;
+        std::shared_ptr<std::ostringstream> _stream;
+
+        const char* baseFilename(const char* path) {
+            const char* p = path + strlen(path);
+            while (p != path) {
+                if (*p == '/') {
+                    return p + 1;
+                }
+                p --;
+            }
+            return path;
+        }
+};
+
+}
+
+#endif
diff --git a/libjconer/include/common/misc.hpp b/libjconer/include/common/misc.hpp
new file mode 100644
index 0000000..08409ea
--- /dev/null
+++ b/libjconer/include/common/misc.hpp
@@ -0,0 +1,84 @@
+#ifndef __common_MISC_HPP__
+#define __common_MISC_HPP__
+
+#ifdef _WIN32
+#include <windows.h>
+#elif MACOS
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/time.h>
+#include <ctime>
+#else
+#include <unistd.h>
+#include <sys/time.h>
+#include <ctime>
+#endif
+
+#include <map>
+
+namespace common {
+
+typedef std::map<std::string, std::string> string_map;
+
+#define CLASS_NOCOPY(class) \
+    private: \
+        class& operator=(class& other); \
+        class(const class& other);
+
+static inline size_t get_ncpu() {
+#ifdef WIN32
+    SYSTEM_INFO sysinfo;
+    GetSystemInfo(&sysinfo);
+    return sysinfo.dwNumberOfProcessors;
+#elif MACOS
+    int nm[2];
+    size_t len = 4;
+    uint32_t count;
+ 
+    nm[0] = CTL_HW; nm[1] = HW_AVAILCPU;
+    sysctl(nm, 2, &count, &len, NULL, 0);
+ 
+    if(count < 1) {
+    nm[1] = HW_NCPU;
+    sysctl(nm, 2, &count, &len, NULL, 0);
+    if(count < 1) { count = 1; }
+    }
+    return count;
+#else
+    return sysconf(_SC_NPROCESSORS_ONLN);
+#endif
+}
+
+static int64_t get_time_in_micro()
+{
+#ifdef WIN32
+     /* Windows */
+    FILETIME ft;
+    LARGE_INTEGER li;
+
+    /* Get the amount of 100 nano seconds intervals elapsed since January 1, 1601 (UTC) and copy it
+     * to a LARGE_INTEGER structure. */
+    GetSystemTimeAsFileTime(&ft);
+    li.LowPart = ft.dwLowDateTime;
+    li.HighPart = ft.dwHighDateTime;
+
+    int64_t ret = li.QuadPart;
+    ret -= 116444736000000000LL; /* Convert from file time to UNIX epoch time. */
+    ret /= 1000; /* From 100 nano seconds (10^-7) to 1 millisecond (10^-3) intervals */
+
+    return ret;
+#else
+    /* Linux */
+    struct timeval tval;
+
+    gettimeofday(&tval, NULL);
+
+    int64_t ret = tval.tv_usec;
+    /* Adds the seconds (10^0) after converting them to milliseconds (10^-3) */
+    ret += (tval.tv_sec * 1000000);
+    return ret;
+#endif
+} 
+}
+
+#endif
diff --git a/libjconer/include/common/path.hpp b/libjconer/include/common/path.hpp
new file mode 100644
index 0000000..07700be
--- /dev/null
+++ b/libjconer/include/common/path.hpp
@@ -0,0 +1,107 @@
+#ifndef __common_PATH_HPP__
+#define __common_PATH_HPP__
+
+#include "common/varstring.hpp"
+#include <stdlib.h>
+#include <string.h>
+#include <utility>
+#include <iostream>
+#include <fstream>
+
+namespace common {
+    
+class Path {
+    public:
+        static inline std::string sep() {
+#ifdef Win32
+            static std::string _sep = "\\";
+#else
+            static std::string _sep = "/";
+#endif
+            return _sep;
+        }
+
+#ifndef Win32
+        static inline std::string devnull() {
+            static std::string _devnull = "/dev/null";
+            return _devnull;
+        }
+#endif
+
+        static inline std::string curdir() {
+            static std::string _curdir = ".";
+            return _curdir;
+        }
+
+        static inline std::string parentdir() {
+            static std::string _parentdir = "..";
+            return _parentdir;
+        }
+
+        static inline std::string pathsep() {
+#ifdef Win32
+            static std::string _pathsep = ";";
+#else
+            static std::string _pathsep = ":";
+#endif
+            return _pathsep;
+        }
+
+        static std::pair<std::string, std::string> split(const std::string& path) {
+            std::string::size_type pos = path.rfind(Path::sep());
+            std::string dir = "", base = "";
+            if (pos != std::string::npos) {
+                dir = path.substr(0, pos);
+                pos ++;
+                base = path.substr(pos);
+            } else {
+                base = path;
+            }
+            return make_pair(dir, base);
+        }
+
+        static std::string join(const std::string& dir, const std::string & base) {
+            std::string rst = "";
+            if (VarString::starts_with(base, Path::sep())) {
+                rst = base;
+            } else {
+                if (VarString::ends_with(dir, Path::sep())) {
+                    rst = dir + base;
+                } else {
+                    rst = dir + Path::sep() + base;
+                }
+            }
+            return rst;
+        }
+
+        static std::string basename(const std::string& path) {
+            return Path::split(path).first;
+        }
+
+        static std::string dirname(const std::string& path) {
+            return Path::split(path).second;
+        }
+
+        static std::pair<std::string, std::string> splitext(const std::string& path) {
+            std::string::size_type pos = path.rfind(".");
+            std::string name = "", ext = "";
+            if (pos != std::string::npos) {
+                name = path.substr(0, pos);
+                ext = path.substr(pos);
+            } else {
+                name = path;
+            }
+            return make_pair(name, ext);
+        }
+
+        static bool exists(const std::string& path) {
+            std::ifstream  fin(path.c_str());
+            bool rst = fin.good();
+            fin.close();
+            return rst;
+        }
+};
+
+}
+
+#endif
diff --git a/libjconer/include/common/property.hpp b/libjconer/include/common/property.hpp
new file mode 100644
index 0000000..7940082
--- /dev/null
+++ b/libjconer/include/common/property.hpp
@@ -0,0 +1,101 @@
+#ifndef __COMMON_PROPERTY_HPP__
+#define __COMMON_PROPERTY_HPP__
+
+#include "common/misc.hpp"
+#include "common/varstring.hpp"
+
+#include <iostream>
+#include <fstream>
+#include <sstream>
+#include <vector>
+
+namespace common {
+
+class Property {
+    public:
+        Property(std::string filename)
+            :_in(* new std::ifstream(filename.c_str())), _own(true)
+        {
+        }
+        Property(std::istream& in)
+            :_in(in), _own(false)
+        {
+            _property.clear();
+            _parse();
+        }
+        ~Property() {
+            if (_own) {
+                ((std::ifstream*)(&_in))->close();
+                delete &_in;
+            }
+        }
+
+        std::string get(std::string key, std::string d = "") {
+            if (_property.find(key) != _property.end())
+                return _property[key];
+            return d;
+        }
+
+        int get_int(std::string key, int d = 0) {
+            std::string value = get(key);
+            if (value == "") {
+                return d;
+            } else {
+                return atoi(value.c_str());
+            }
+        }
+
+        double get_real(std::string key, double d = 0.0) {
+            std::string value = get(key);
+            if (value == "") {
+                return d;
+            } else {
+                return atof(value.c_str());
+            }
+        }
+
+        bool get_bool(std::string key, bool d = false) {
+            std::string value = get(key);
+            if (value == "") {
+                return d;
+            } else {
+                std::string lower = VarString::tolower(value);
+                if (lower == "false" || lower == "0") return false;
+                if (lower == "true" || lower == "1") return true;
+                return d;
+            }
+        }
+
+    private:
+        std::istream& _in;
+        bool _own;
+        string_map _property;
+
+        void _parse(){
+            while(true) {
+                std::string line;
+                getline(_in, line);
+                if (_in.good()) {
+                    if (line == "" || line[0] == '#') {
+                        continue;
+                    } else {
+                        std::vector<std::string> parts = VarString::split(line, "=");
+                        if (parts.size() == 1) {
+                            continue;
+                        } else {
+                            std::string key = VarString::strip(parts[0]);
+                            std::string value = VarString::strip(parts[1]);
+                            _property[key] = value;
+                            std::cout << key << " " << value << std::endl;
+                        }
+                    }
+                } else {
+                    break;
+                }
+            }
+        }
+};
+
+}
+
+#endif
diff --git a/libjconer/include/common/queue.hpp b/libjconer/include/common/queue.hpp
new file mode 100644
index 0000000..ae449b2
--- /dev/null
+++ b/libjconer/include/common/queue.hpp
@@ -0,0 +1,88 @@
+#ifndef __common_QUEUE_HPP__
+#define __common_QUEUE_HPP__
+
+#include "common/misc.hpp"
+#include "common/threading.hpp"
+#include <pthread.h>
+#include <deque>
+#include <stdio.h>
+
+namespace common {
+
+template<class T>
+class Queue {
+    public:
+        Queue(size_t size = 0)
+            :_lock(), _empty_cond(&_lock), _full_cond(&_lock), _size(size)
+        {
+        }
+        ~Queue() {
+            _queue.clear();
+        }
+
+        void push(const T& item) {
+            _lock.lock();
+            size_t queue_size = _queue.size();
+            if (_size != 0 && queue_size == _size) {
+                _full_cond.wait();
+                _queue.push_back(item);
+            } else {
+                _queue.push_back(item);
+                _empty_cond.notify();
+            }
+            _lock.unlock();
+        }
+
+        bool try_pop(T* item) {
+            _lock.lock();
+            size_t queue_size = _queue.size();
+            bool rst = false;
+            if (queue_size != 0) {
+                *item = _queue.front();
+                _queue.pop_front();
+                rst = true;
+                if (queue_size == _size - 1) {
+                    _full_cond.notify();
+                }
+            }
+            _lock.unlock();
+            return rst;
+        }
+        
+        T pop() {
+            _lock.lock();
+            while(_queue.empty()) {
+                _empty_cond.wait();
+            }
+
+            T item = _queue.front();
+            _queue.pop_front();
+            if (_queue.size() == _size - 1) {
+                _full_cond.notify();
+            }
+            _lock.unlock();
+            return item;
+        }
+
+        size_t size() {
+            _lock.lock();
+            size_t size = _queue.size();
+            _lock.unlock();
+            return size;
+        }
+
+        size_t capacity() const { return _size; }
+        void clear() { _queue.clear(); }
+
+    private:
+        std::deque<T> _queue;
+        Mutex _lock;
+        Condition _empty_cond;
+        Condition _full_cond;
+        size_t _size;
+};
+
+
+}
+
+#endif
diff --git a/libjconer/include/common/threading.hpp b/libjconer/include/common/threading.hpp
new file mode 100644
index 0000000..c7426f3
--- /dev/null
+++ b/libjconer/include/common/threading.hpp
@@ -0,0 +1,548 @@
+#ifndef __common_THREADING_HPP__
+#define __common_THREADING_HPP__
+
+#include <pthread.h>
+#include <stdio.h>
+#include <time.h>
+#include "common/misc.hpp"
+
+namespace common {
+
+class Lock {
+    CLASS_NOCOPY(Lock)
+    public:
+        Lock(){}
+        virtual void lock() = 0;
+        virtual void unlock() = 0;
+        virtual ~Lock() {}
+};
+
+class Mutex : public Lock {
+    CLASS_NOCOPY(Mutex)
+    public:
+        Mutex() {
+            pthread_mutex_init(&_lock, NULL);
+        }
+        ~Mutex() {
+            pthread_mutex_destroy(&_lock);
+        }
+        void lock() {
+            pthread_mutex_lock(&_lock);
+        }
+        void unlock() {
+            pthread_mutex_unlock(&_lock);
+        }
+    private:
+        pthread_mutex_t _lock;
+        friend class Condition;
+};
+
+class RecursiveMutex : public Lock {
+    CLASS_NOCOPY(RecursiveMutex)
+    public:
+        RecursiveMutex() {
+            pthread_mutexattr_init(&_attr);
+            pthread_mutexattr_settype(&_attr, PTHREAD_MUTEX_RECURSIVE);
+
+            pthread_mutex_init(&_lock, &_attr);
+        }
+        ~RecursiveMutex() {
+            pthread_mutexattr_destroy(&_attr);
+            pthread_mutex_destroy(&_lock);
+        }
+        void lock() {
+            pthread_mutex_lock(&_lock);
+        }
+        void unlock() {
+            pthread_mutex_unlock(&_lock);
+        }
+    private:
+        pthread_mutex_t _lock;
+        pthread_mutexattr_t _attr;
+        friend class Condition;
+};
+
+class ScopeLock {
+    public:
+        ScopeLock(Lock* lock) {
+            _lock = lock;
+            _lock->lock();
+        }
+        ~ScopeLock() {
+            _lock->unlock();
+        }
+    private:
+        Lock* _lock;
+};
+
+class Condition {
+    CLASS_NOCOPY(Condition)
+    public:
+        Condition(Mutex* lock) {
+            _lock = lock;
+            pthread_cond_init(&_cond, NULL);
+        }
+        ~Condition(){
+            pthread_cond_destroy(&_cond);
+        }
+
+        void wait() {
+            pthread_cond_wait(&_cond, &_lock->_lock); 
+        }
+
+        void notify() {
+            pthread_cond_signal(&_cond);
+        }
+
+        void notify_all() {
+            pthread_cond_broadcast(&_cond);
+        }
+    private:
+        pthread_cond_t _cond;
+        Mutex* _lock;
+};
+
+class Runable {
+    public:
+        virtual void run() = 0;
+        virtual ~Runable(){}
+};
+
+class Thread: public Runable {
+    public:
+        Thread(const Runable& runable) {
+            _joinable = true;
+            _active = false;
+            _context = &runable;
+        }
+        Thread() {
+            _joinable = true;
+            _active = false;
+            _context = NULL;
+        }
+
+        virtual void run() {
+        }
+
+        bool start() {
+            if (_active == true) {
+                return false;
+            }
+            if (_context == NULL) {
+                _context = this;
+            }
+
+            int r = pthread_create(&_thread_id, NULL, &Thread::_run_thread, (void*)_context);
+            if (r != 0) {
+                return false;
+            }
+            _active = true;
+            return true;
+        }
+
+        long thread_id() const { return (long)_thread_id; }
+
+        bool join() {
+            if (_joinable == false) return false;
+
+            int r = pthread_join(_thread_id, NULL);
+
+            if (r != 0) {
+                return false;
+            }
+            _active = false;
+            return true;
+        }
+
+        bool is_active() {
+            return _active;
+        }
+
+        virtual ~Thread() {
+            if (_active)
+                join();
+        }
+
+    private:
+        static void* _run_thread(void* context) {
+            Runable * self = (Runable*)context;
+            self->run();
+            pthread_exit(NULL);
+            return NULL;
+        }
+
+        pthread_t _thread_id;
+        const Runable * _context;
+
+        bool _active;
+        bool _joinable;
+};
+
+class AsyncMethod {
+    public:
+        AsyncMethod(): _runable(NULL), _thread(NULL) {
+        }
+        void start_async(void (*fn) (void) ) {
+            _check();
+            typedef void (*FUNC) (void);
+            class VVRunable : public Runable {
+                public:
+                    VVRunable(FUNC fn) : _fn(fn) {
+                    }
+                    void run() {
+                        _fn();
+                    }
+                private:
+                    FUNC _fn;
+            };
+            _runable = new VVRunable(fn);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class R>
+        void start_async(R (*fn) (void), R* r) {
+            _check();
+            typedef R (*FUNC) (void);
+
+            class RVRunable : public Runable {
+                public:
+                    RVRunable(FUNC fn, R* r) : _fn(fn), _r(r){
+                    }
+                    void run() {
+                        *_r = _fn();
+                    }
+                private:
+                    FUNC _fn;
+                    R* _r;
+            };
+
+            _runable = new  RVRunable(fn, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class A1>
+        void start_async(void (*fn) (A1) , A1 a1) {
+            _check();
+            typedef void (*FUNC) (A1);
+
+            class VA1Runable : public Runable {
+                public:
+                    VA1Runable(FUNC fn, A1 a1) : _fn(fn), _a1(a1){
+                    }
+                    void run() {
+                        _fn(_a1);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+            };
+
+            _runable = new  VA1Runable(fn, a1);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C>
+        void start_async(void (C::*fn)(), C* c) {
+            _check();
+            typedef void (C::*FUNC)();
+            class VCVRunable : public Runable {
+                public:
+                    VCVRunable(FUNC fn, C* c) : _fn(fn), _c(c){
+                    }
+                    void run() {
+                        (_c->*_fn)();
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+            };
+
+            _runable = new  VCVRunable(fn, c);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class A1, class R>
+        void start_async(R (*fn) (A1), A1 a1, R*r) {
+            _check();
+            typedef R (*FUNC) (A1);
+
+            class RA1Runable : public Runable {
+                public:
+                    RA1Runable(FUNC fn, A1 a1, R* r) : _fn(fn), _a1(a1), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    R* _r;
+            };
+
+            _runable = new RA1Runable(fn, a1, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class R>
+        void start_async(R (C::*fn) (), C* c, R* r) {
+            _check();
+            typedef R (C::*FUNC) ();
+
+            class RCVRunable : public Runable {
+                public:
+                    RCVRunable(FUNC fn, C* c, R* r) : _fn(fn), _c(c), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)();
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    R* _r;
+            };
+
+            _runable = new RCVRunable(fn, c, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+
+        template<class A1, class A2>
+        void start_async(void (*fn) (A1, A2) , A1 a1, A2 a2) {
+            _check();
+            typedef void (*FUNC) (A1, A2);
+
+            class VA2Runable : public Runable {
+                public:
+                    VA2Runable(FUNC fn, A1 a1, A2 a2) : _fn(fn), _a1(a1), _a2(a2) {
+                    }
+                    void run() {
+                        _fn(_a1, _a2);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+            };
+
+            _runable = new  VA2Runable(fn, a1, a2);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class A1>
+        void start_async(void (C::*fn) (A1), C* c, A1 a1) {
+            _check();
+            typedef void (C::*FUNC) (A1);
+
+            class VCA1Runable : public Runable {
+                public:
+                    VCA1Runable(FUNC fn, C* c, A1 a1) : _fn(fn), _c(c), _a1(a1) {
+                    }
+                    void run() {
+                        (_c->*_fn)(_a1);
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+            };
+
+            _runable = new  VCA1Runable(fn, c, a1);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+
+        template<class A1, class A2, class R>
+        void start_async(R (*fn) (A1, A2), A1 a1, A2 a2, R*r) {
+            _check();
+            typedef R (*FUNC) (A1, A2);
+
+            class RA2Runable : public Runable {
+                public:
+                    RA2Runable(FUNC fn, A1 a1, A2 a2, R* r) : _fn(fn), _a1(a1), _a2(a2), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1, _a2);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    R* _r;
+            };
+
+            _runable = new RA2Runable(fn, a1, a2, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class A1, class R>
+        void start_async(R (C::*fn) (A1), C* c, A1 a1, R*r) {
+            _check();
+            typedef R (C::*FUNC) (A1);
+
+            class RCA1Runable : public Runable {
+                public:
+                    RCA1Runable(FUNC fn, C* c, A1 a1, R* r) : _fn(fn), _c(c), _a1(a1), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)(_a1);
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    R* _r;
+            };
+
+            _runable = new RCA1Runable(fn, c, a1, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+
+        template<class A1, class A2, class A3>
+        void start_async(void (*fn) (A1, A2, A3) , A1 a1, A2 a2, A3 a3) {
+            _check();
+            typedef void (*FUNC) (A1, A2, A3);
+
+            class VA3Runable : public Runable {
+                public:
+                    VA3Runable(FUNC fn, A1 a1, A2 a2, A3 a3) : _fn(fn), _a1(a1), _a2(a2), _a3(a3){
+                    }
+                    void run() {
+                        _fn(_a1, _a2, _a3);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    A3 _a3;
+            };
+
+            _runable = new  VA3Runable(fn, a1, a2, a3);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class A1, class A2>
+        void start_async(void (C::*fn) (A1, A2) , C* c, A1 a1, A2 a2) {
+            _check();
+            typedef void (C::*FUNC) (A1, A2);
+
+            class VCA2Runable : public Runable {
+                public:
+                    VCA2Runable(FUNC fn, C* c, A1 a1, A2 a2) : _fn(fn), _c(c), _a1(a1), _a2(a2){
+                    }
+                    void run() {
+                        (_c->*_fn)(_a1, _a2);
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    A2 _a2;
+            };
+
+            _runable = new  VCA2Runable(fn, c, a1, a2);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class A1, class A2, class A3, class R>
+        void start_async(R (*fn) (A1, A2, A3), A1 a1, A2 a2, A3 a3, R*r) {
+            _check();
+            typedef R (*FUNC) (A1, A2, A3);
+
+            class RA3Runable : public Runable {
+                public:
+                    RA3Runable(FUNC fn, A1 a1, A2 a2, A3 a3, R* r) : _fn(fn), _a1(a1), _a2(a2), _a3(a3), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1, _a2, _a3);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    A3 _a3;
+                    R* _r;
+            };
+
+            _runable = new RA3Runable(fn, a1, a2, a3, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+        template<class C, class A1, class A2, class R>
+        void start_async(R (C::*fn) (A1, A2), C* c, A1 a1, A2 a2, R*r) {
+            _check();
+            typedef R (C::*FUNC) (A1, A2);
+
+            class RCA2Runable : public Runable {
+                public:
+                    RCA2Runable(FUNC fn, C* c, A1 a1, A2 a2, R* r) : _fn(fn), _c(c), _a1(a1), _a2(a2), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)(_a1, _a2);
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    A2 _a2;
+                    R* _r;
+            };
+
+            _runable = new RCA2Runable(fn, c, a1, a2, r);
+            _thread = new Thread(*_runable);
+            _thread->start();
+        }
+
+
+        void wait() {
+          _thread->join();
+        }
+
+        ~AsyncMethod() {
+            _thread->join();
+            if (_runable) delete _runable;
+            if (_thread) delete _thread;
+        }
+
+    private:
+        Runable *_runable;
+        Thread *_thread;
+
+
+        void _check(){
+          if (_runable != nullptr) {
+            _thread->join();
+            delete _runable;
+            delete _thread;
+          }
+        }
+};
+
+}
+
+#endif
diff --git a/libjconer/include/common/threadpool.hpp b/libjconer/include/common/threadpool.hpp
new file mode 100644
index 0000000..de2f60a
--- /dev/null
+++ b/libjconer/include/common/threadpool.hpp
@@ -0,0 +1,418 @@
+#ifndef __common_THREADPOOL_HPP__
+#define __common_THREADPOOL_HPP__
+
+#include "common/misc.hpp"
+#include "common/queue.hpp"
+#include <time.h>
+#include <pthread.h>
+#include <assert.h>
+#include <stdio.h>
+#include <functional>
+
+namespace common {
+
+typedef void (*func) (void*);
+
+class Job {
+    public:
+        virtual void run() = 0;
+        virtual ~Job() {}
+};
+
+#define TP_IMMEDIATE_SHUTDOWN 0
+#define TP_POSTPONED_SHUTDOWN 1
+
+class ThreadPool {
+    CLASS_NOCOPY(ThreadPool)
+    public:
+        ThreadPool(size_t pool_size = get_ncpu(), size_t queue_size = 2 * get_ncpu())
+            :_task_queue(queue_size), _pool_size(pool_size)
+        {
+            pthread_mutex_init(&_lock, NULL);
+            _stop = false;
+            _shutdown = -1;
+            assert(_pool_size > 0);
+            _pool = (pthread_t*) malloc(sizeof(pthread_t) * _pool_size);
+            assert(_pool != NULL);
+            _active_count = 0;
+
+            pthread_mutex_lock(&_lock);
+            size_t i;
+            for(i = 0; i < _pool_size; i ++ ) {
+                int ret = pthread_create(&_pool[i], NULL, _run_thread, (void*)this);
+                if (ret != 0) {
+                    pthread_mutex_unlock(&_lock);
+                    destroy();
+                    break;
+                } else {
+                    _active_count ++;
+                }
+            }
+            if (i == _pool_size) pthread_mutex_unlock(&_lock);
+        }
+
+        void destroy(int shutdown = TP_IMMEDIATE_SHUTDOWN) {
+            if (shutdown != TP_IMMEDIATE_SHUTDOWN && shutdown != TP_POSTPONED_SHUTDOWN) {
+                _shutdown = TP_IMMEDIATE_SHUTDOWN;
+            } else {
+                _shutdown = shutdown;
+            }
+            for(size_t i = 0; i < _active_count; i ++ ) {
+                pthread_join(_pool[i], NULL);
+            }
+            _task_queue.clear();
+            free(_pool);
+            _pool = NULL;
+            _stop = true;
+        }
+
+        bool add(void (*fn) (void) ) {
+            typedef void (*FUNC) (void);
+            class VVJob : public Job {
+                public:
+                    VVJob(FUNC fn) : _fn(fn) {
+                    }
+                    void run() {
+                        _fn();
+                    }
+                private:
+                    FUNC _fn;
+            };
+            _task_queue.push(new VVJob(fn));
+            return true;
+        }
+
+        template<class C>
+        bool add(void (C::*fn) (void), C* c) {
+            typedef void (C::*FUNC) (void);
+            class VCVJob : public Job {
+                public:
+                    VCVJob(FUNC fn, C* c) : _fn(fn), _c(c) {
+                    }
+                    void run() {
+                        (_c->*_fn)();
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+            };
+            _task_queue.push(new VCVJob(fn, c));
+            return true;
+        }
+
+
+        template<class R>
+        bool add(R (*fn)(void), R* r) {
+            typedef R (*FUNC) (void);
+
+            class RVJob : public Job {
+                public:
+                    RVJob(FUNC fn, R* r) : _fn(fn), _r(r){
+                    }
+                    void run() {
+                        *_r = _fn();
+                    }
+                private:
+                    FUNC _fn;
+                    R* _r;
+            };
+
+            _task_queue.push(new  RVJob(fn, r));
+            return true;
+        }
+
+        template<class C, class R>
+        bool add(R (C::*fn)(void), C* c, R* r) {
+            typedef R (C::*FUNC) (void);
+
+            class RCVJob : public Job {
+                public:
+                    RCVJob(FUNC fn, C* c, R* r) : _fn(fn), _c(c), _r(r){
+                    }
+                    void run() {
+                        *_r = (_c->*_fn)();
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    R* _r;
+            };
+
+            _task_queue.push(new  RCVJob(fn, c, r));
+            return true;
+        }
+
+
+        template<class A1>
+        bool add(void (*fn) (A1) , A1 a1) {
+            typedef void (*FUNC) (A1);
+
+            class VA1Job : public Job {
+                public:
+                    VA1Job(FUNC fn, A1 a1) : _fn(fn), _a1(a1){
+                    }
+                    void run() {
+                        _fn(_a1);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+            };
+
+            _task_queue.push(new  VA1Job(fn, a1));
+            return true;
+        }
+
+        template<class C, class A1>
+        bool add(void (C::*fn) (A1) , C* c, A1 a1) {
+            typedef void (C::*FUNC) (A1);
+
+            class VCA1Job : public Job {
+                public:
+                    VCA1Job(FUNC fn, C* c, A1 a1) : _fn(fn), _c(c), _a1(a1){
+                    }
+                    void run() {
+                        (_c->*_fn)(_a1);
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+            };
+
+            _task_queue.push(new  VCA1Job(fn, c, a1));
+            return true;
+        }
+
+        template<class A1, class R>
+        bool add(R (*fn) (A1), A1 a1, R*r) {
+            typedef R (*FUNC) (A1);
+
+            class RA1Job : public Job {
+                public:
+                    RA1Job(FUNC fn, A1 a1, R* r) : _fn(fn), _a1(a1), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    R* _r;
+            };
+
+            _task_queue.push(new RA1Job(fn, a1, r));
+            return true;
+        }
+
+        template<class C, class A1, class R>
+        bool add(R (C::*fn) (A1), C* c, A1 a1, R*r) {
+            typedef R (C::*FUNC) (A1);
+
+            class RCA1Job : public Job {
+                public:
+                    RCA1Job(FUNC fn, C* c, A1 a1, R* r) : _fn(fn), _c(c), _a1(a1), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)(_a1);
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    R* _r;
+            };
+
+            _task_queue.push(new RCA1Job(fn, c, a1, r));
+            return true;
+        }
+
+        template<class A1, class A2>
+        bool add(void (*fn) (A1, A2) , A1 a1, A2 a2) {
+            typedef void (*FUNC) (A1, A2);
+
+            class VA2Job : public Job {
+                public:
+                    VA2Job(FUNC fn, A1 a1, A2 a2) : _fn(fn), _a1(a1), _a2(a2) {
+                    }
+                    void run() {
+                        _fn(_a1, _a2);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+            };
+
+            _task_queue.push(new  VA2Job(fn, a1, a2));
+            return true;
+        }
+
+        template<class C, class A1, class A2>
+        bool add(void (C::*fn) (A1, A2) , C* c, A1 a1, A2 a2) {
+            typedef void (C::*FUNC) (A1, A2);
+
+            class VCA2Job : public Job {
+                public:
+                    VCA2Job(FUNC fn, C* c, A1 a1, A2 a2) : _fn(fn), _c(c), _a1(a1), _a2(a2) {
+                    }
+                    void run() {
+                        (_c->*_fn)(_a1, _a2);
+                    }
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    A2 _a2;
+            };
+
+            _task_queue.push(new  VCA2Job(fn, c, a1, a2));
+            return true;
+        }
+
+        template<class A1, class A2, class R>
+        bool add(R (*fn) (A1, A2), A1 a1, A2 a2, R*r) {
+            typedef R (*FUNC) (A1, A2);
+
+            class RA2Job : public Job {
+                public:
+                    RA2Job(FUNC fn, A1 a1, A2 a2, R* r) : _fn(fn), _a1(a1), _a2(a2), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1, _a2);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    R* _r;
+            };
+
+            _task_queue.push(new RA2Job(fn, a1, a2, r));
+            return true;
+        }
+
+        template<class C, class A1, class A2, class R>
+        bool add(R (C::*fn) (A1, A2), C* c, A1 a1, A2 a2, R*r) {
+            typedef R (C::*FUNC) (A1, A2);
+
+            class RCA2Job : public Job {
+                public:
+                    RCA2Job(FUNC fn, C* c, A1 a1, A2 a2, R* r) : _fn(fn), _c(c), _a1(a1), _a2(a2), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = (_c->*_fn)(_a1, _a2);
+                    }
+
+                private:
+                    FUNC _fn;
+                    C* _c;
+                    A1 _a1;
+                    A2 _a2;
+                    R* _r;
+            };
+
+            _task_queue.push(new RCA2Job(fn, c, a1, a2, r));
+            return true;
+        }
+
+
+        template<class A1, class A2, class A3>
+        bool add(void (*fn) (A1, A2, A3) , A1 a1, A2 a2, A3 a3) {
+            typedef void (*FUNC) (A1, A2, A3);
+
+            class VA3Job : public Job {
+                public:
+                    VA3Job(FUNC fn, A1 a1, A2 a2, A3 a3) : _fn(fn), _a1(a1), _a2(a2), _a3(a3){
+                    }
+                    void run() {
+                        _fn(_a1, _a2, _a3);
+                    }
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    A3 _a3;
+            };
+
+            _task_queue.push(new  VA3Job(fn, a1, a2, a3));
+            return true;
+        }
+
+        template<class A1, class A2, class A3, class R>
+        bool add(R (*fn) (A1, A2, A3), A1 a1, A2 a2, A3 a3, R*r) {
+            typedef R (*FUNC) (A1, A2, A3);
+
+            class RA3Job : public Job {
+                public:
+                    RA3Job(FUNC fn, A1 a1, A2 a2, A3 a3, R* r) : _fn(fn), _a1(a1), _a2(a2), _a3(a3), _r(r) {
+                    }
+
+                    void run() {
+                        *_r = _fn(_a1, _a2, _a3);
+                    }
+
+                private:
+                    FUNC _fn;
+                    A1 _a1;
+                    A2 _a2;
+                    A3 _a3;
+                    R* _r;
+            };
+
+            _task_queue.push(new RA3Job(fn, a1, a2, a3, r));
+            return true;
+        }
+        
+
+        ~ThreadPool() {
+            if (!_stop) {
+                destroy();
+            }
+        }
+    private:
+        Queue<Job*> _task_queue;
+        pthread_mutex_t _lock;
+        pthread_t* _pool;
+        int _shutdown;
+        size_t _pool_size;
+        bool _stop;
+        size_t _active_count;
+
+        static void* _run_thread(void* context) {
+            ThreadPool* self = (ThreadPool*)context;
+
+            for(;;) {
+                if (self->_shutdown == TP_IMMEDIATE_SHUTDOWN) {
+                    break;
+                } else if (self->_shutdown == TP_POSTPONED_SHUTDOWN && self->_task_queue.size() == 0) {
+                    //fprintf(stderr, "Postponed shutdown");
+                    break;
+                }
+
+                Job* job = nullptr;
+                if (self->_task_queue.try_pop(&job)) {
+                    job->run();
+                    delete job;
+                } else {
+                    struct timespec ts;
+                    ts.tv_sec = 0;
+                    ts.tv_nsec = 1000; // 1us
+                    nanosleep(&ts, NULL);
+                }
+            }
+            pthread_exit(NULL);
+            return NULL;
+        }
+};
+
+}
+
+#endif
diff --git a/libjconer/include/common/timer.hpp b/libjconer/include/common/timer.hpp
new file mode 100644
index 0000000..eafaa71
--- /dev/null
+++ b/libjconer/include/common/timer.hpp
@@ -0,0 +1,52 @@
+#ifndef __common_TIMER_HPP__
+#define __common_TIMER_HPP__
+
+#include <string.h>
+
+#include "common/misc.hpp"
+
+namespace common {
+
+
+class Timer {
+    CLASS_NOCOPY(Timer)
+    public:
+        Timer() {
+            _start = get_time_in_micro();
+        }
+
+        void start() {
+            _start = get_time_in_micro();
+        }
+
+        int64_t elapsed() {
+            _end = get_time_in_micro();
+            return _end - _start;
+        }
+
+
+    private:
+        int64_t _start;
+        int64_t _end;
+};
+
+class ScopeTimer {
+    public:
+        ScopeTimer(const char* name)
+            :_timer(), _name(name) 
+        {
+        }
+
+        ~ScopeTimer() {
+            int64_t elapsed = _timer.elapsed();
+            fprintf(stderr, "[%s]: %fs\n", _name.c_str(), elapsed * 1.0 / 1000000);
+        }
+
+    private:
+        Timer _timer;
+        std::string  _name;
+};
+
+}
+
+#endif
diff --git a/libjconer/include/common/varstring.hpp b/libjconer/include/common/varstring.hpp
new file mode 100644
index 0000000..1297de3
--- /dev/null
+++ b/libjconer/include/common/varstring.hpp
@@ -0,0 +1,249 @@
+#ifndef __common_VARSTRING_HPP__
+#define __common_VARSTRING_HPP__
+#include <string>
+#include <map>
+#include <set>
+#include <vector>
+#include <cctype>
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#define BUFSIZE 1024
+#define MALLOC(type, ptr, size) do {\
+    if (((ptr) = (type*)malloc(size)) == NULL) {\
+        fprintf(stderr, "Run out of memory at %s, %d\n", __FILE__, __LINE__);\
+        exit(-1);\
+    }\
+} while(0)
+
+#define REALLOC(type, ptr, size)  do {\
+    if (((ptr) = (type*)realloc(ptr, size)) == NULL) {\
+        fprintf(stderr, "Run out of memory at %s, %d\n", __FILE__, __LINE__);\
+        exit(-1);\
+    }\
+} while(0)
+
+
+
+namespace common {
+
+class VarString {
+    public:
+        static std::string tolower(const std::string str) {
+            size_t size = str.size();
+            const char* p_str = str.c_str();
+            char* rst = NULL;
+            MALLOC(char, rst, size);
+            for(size_t i = 0; i < size; i ++ ) {
+                if (p_str[i] <= 'Z' && p_str[i] >= 'A') {
+                    rst[i] = p_str[i] + 32;
+                }
+                else {
+                    rst[i] = p_str[i];
+                }
+            }
+            std::string str_rst(rst, size);
+            free(rst);
+            return str_rst;
+        }
+
+        static std::string toupper(const std::string str) {
+            size_t size = str.size();
+            const char* p_str = str.c_str();
+            char* rst = NULL;
+            MALLOC(char, rst, size);
+            for(size_t i = 0; i < size; i ++ ) {
+                if (p_str[i] <= 'z' && p_str[i] >= 'a') {
+                    rst[i] = p_str[i] - 32;
+                }
+                else {
+                    rst[i] = p_str[i];
+                }
+            }
+            std::string str_rst(rst, size);
+            free(rst);
+            return str_rst;
+        }
+        
+        static std::string itos(int i) {
+            char tmp[20];
+            sprintf(tmp, "%d", i);
+            return std::string(tmp);
+        }
+
+        static std::string join(std::set<std::string> vec, std::string sep) {
+            if (vec.size() == 0) return "";
+            VarString vs;
+            int len = sep.size();
+            //for(int i = 0; i < vec.size(); i ++ ) {
+            for(std::set<std::string>::iterator iter = vec.begin();
+                    iter != vec.end(); iter ++) {
+                vs.append(*iter).append(sep);
+            }
+            vs.drop(len);
+            return vs.toString();
+        }
+
+        static std::vector<std::string> split(const std::string str, const std::string delim) {
+            std::vector<std::string> rst;
+            size_t pos = 0;
+            while(true) {
+                size_t next = str.find(delim, pos);
+                if (next != std::string::npos) {
+                    rst.push_back(str.substr(pos, next - pos));
+                    pos = next + delim.size();
+                } else {
+                    rst.push_back(str.substr(pos));
+                    break;
+                }
+            }
+            return rst;
+        }
+
+        static std::string format(const char* fmt, ...) {
+            va_list va;
+            va_start(va, fmt);
+            char fullstring[1024];
+            vsnprintf(fullstring, 1023, fmt, va);
+            va_end(va);
+            return std::string(fullstring);
+        }
+
+        static bool starts_with(const std::string str, const std::string prefix) {
+            return str.compare(0, prefix.size(), prefix) == 0;
+        }
+
+        static bool ends_with(const std::string str, const std::string suffix) {
+            const char* p = str.c_str() + str.size();
+            const char* q = suffix.c_str() + suffix.size();
+            for(size_t i = 0; i < suffix.size(); i ++ ) {
+                if (*(p -i - 1) != *(q -i -1)) return false;
+            }
+            return true;
+        }
+
+        static std::string lstrip(const std::string str) {
+            size_t pos = 0;
+            while(pos < str.size() && std::isspace(str[pos])) pos ++;
+            return std::string(str, pos, str.size() - pos);
+        }
+
+        static std::string rstrip(const std::string str) {
+            int pos = str.size() - 1;
+            while(pos >= 0 && std::isspace(str[pos])) pos --;
+            return std::string(str, 0, pos + 1);
+        }
+
+        static std::string strip(const std::string str) {
+            return rstrip(lstrip(str));
+        }
+
+        VarString() {
+            MALLOC(char, _p, BUFSIZE);
+            _cur = _p;
+            _capacity = BUFSIZE;
+        }
+        
+        inline VarString& append(char c) {
+            if (_cur - _p == _capacity - 1) {
+                REALLOC(char, _p, _capacity * 2);
+                _cur = _p + _capacity - 1;
+                _capacity *= 2;
+            }
+
+            *_cur++ = c;
+            return *this;
+        }
+
+        inline VarString& drop() {
+            if (_cur != _p) {
+                _cur --;
+            }
+            return *this;
+        }
+
+        inline VarString& drop(unsigned int len) {
+            if (_cur - len < _p) {
+                len = _p - _cur;
+            }
+            _cur -= len;
+            return *this;
+        }
+
+        VarString& append(const char* p) {
+            int len = strlen(p);
+            return append(p, len);
+        }
+
+        VarString& append(const std::string str) {
+            return append(str.c_str());
+        }
+
+        VarString& append(const char* p, const char c) {
+            append(p);
+            append(c);
+            return *this;
+        }
+
+        VarString& append(const std::string str, const char c) {
+            return append(str.c_str(), c);
+        }
+
+        VarString& append(const char* p1, const char c, const char* p2) {
+            append(p1);
+            append(c);
+            append(p2);
+            return *this;
+        }
+
+        VarString& append(const std::string str1, const char c, const std::string str2) {
+            return append(str1.c_str(), c, str2.c_str());
+        }
+
+        VarString& append(const char* p, int n) {
+            if (_cur - _p + n > _capacity - 1) {
+                int cur_size = _cur - _p;
+                int new_length = 0;
+                if (_cur - _p + n < _capacity * 2 - 1) {
+                    new_length = _capacity * 2; 
+                } else {
+                    new_length = cur_size + n + BUFSIZE;
+                }
+
+                REALLOC(char, _p, new_length);
+                _cur = _p + cur_size;
+                _capacity = new_length;
+            }
+            memcpy(_cur, p, n); 
+            _cur += n;
+            return *this;
+        }
+
+        inline std::string toString() {
+            std::string s(_p, _cur - _p);
+            return s;
+        }
+
+        inline void clear() {
+            _cur = _p;
+        }
+
+        inline int size() const { return _cur - _p; }
+
+        ~VarString() {
+            free(_p);
+        }
+    private:
+        char* _p;
+        char* _cur;
+        int _capacity;
+        VarString(const VarString&);
+        VarString operator=(const VarString&);
+};
+
+
+
+}
+
+#endif
diff --git a/libjconer/include/jconer/allocator.hpp b/libjconer/include/jconer/allocator.hpp
new file mode 100644
index 0000000..aba9a03
--- /dev/null
+++ b/libjconer/include/jconer/allocator.hpp
@@ -0,0 +1,48 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __ALLOCATOR_HPP__
+#define __ALLOCATOR_HPP__
+#include <stdio.h>
+#include "jconer/arena.hpp"
+
+class Allocator {
+  public:
+    Allocator() {
+      arena_ =  arena_New();
+      /*if (arena_ == NULL) {
+        throw std::bad_alloc();
+      }*/
+    }
+    virtual ~Allocator() {
+      arena_Free(arena_);
+    }
+
+    void * malloc(size_t size) {
+      return arena_Malloc(arena_, size);
+    }
+  private:
+    Arena* arena_;
+};
+
+void* allocate(size_t size) /*throw (std::bad_alloc)*/;
+#endif
diff --git a/libjconer/include/jconer/arena.hpp b/libjconer/include/jconer/arena.hpp
new file mode 100644
index 0000000..25d37e4
--- /dev/null
+++ b/libjconer/include/jconer/arena.hpp
@@ -0,0 +1,32 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __PYARENA_H__
+#define __PYARENA_H__
+
+typedef struct _arena Arena;
+
+Arena * arena_New(void);
+void arena_Free(Arena *);
+
+void* arena_Malloc(Arena *, size_t size);
+#endif /* !Py_PYARENA_H */
diff --git a/libjconer/include/jconer/dump.hpp b/libjconer/include/jconer/dump.hpp
new file mode 100644
index 0000000..4a3d869
--- /dev/null
+++ b/libjconer/include/jconer/dump.hpp
@@ -0,0 +1,49 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_DUMP_HPP__
+#define __JCONER_DUMP_HPP__
+
+#include "jconer/token.hpp"
+#include "jconer/value.hpp"
+#include "jconer/stream.hpp"
+#include "jconer/parser.hpp"
+
+#include <iostream>
+
+#define DUMP_SORT_KEY 0x01
+#define DUMP_PRETTY_PRINT 0x02
+#define DUMP_ENSURE_ASCII 0x04
+#define DUMP_COMPACT_PRINT 0x08
+
+#define DUMP_INDENT 4
+
+namespace JCONER {
+
+void dump(JValue* value, std::ostream& out, int flag = DUMP_ENSURE_ASCII);
+void dumpFile(JValue* value, std::string filename, int flag = DUMP_ENSURE_ASCII);
+std::string dumps(JValue* value, int flag = DUMP_ENSURE_ASCII);
+void dumps(JValue* value, char** pbuffer, int flag = DUMP_ENSURE_ASCII);
+
+}
+
+#endif
diff --git a/libjconer/include/jconer/error.hpp b/libjconer/include/jconer/error.hpp
new file mode 100644
index 0000000..a948760
--- /dev/null
+++ b/libjconer/include/jconer/error.hpp
@@ -0,0 +1,101 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_ERROR_HPP__
+#define __JCONER_ERROR_HPP__
+
+#include "jconer/util.hpp"
+#include <stdarg.h>
+#include <string.h>
+#include <stdio.h>
+
+#define BUFSIZE 1024
+
+namespace JCONER {
+enum ErrorType {
+    ET_SUC = 0,
+    ET_IO_FILE_NOT_FOUND,
+    ET_IO_STREAM_NOT_FOUND,
+    ET_IO_READ,
+    ET_PARSE_EOF,
+    ET_PARSE_INVALID_CHAR,
+    ET_PARSE_INVALID_UNICODE,
+    ET_PARSE_INVALID_TOKEN,
+    ET_PARSE_RANGE,
+    ET_PARSE_UNEXPECTED_TOKEN,
+};
+
+struct PError {
+    PError()
+        :lineno(-1), col(-1),
+         type(ET_SUC)
+    {}
+    PError(int lineno_, int col_, std::string text_, ErrorType type_)
+        :lineno(lineno_),
+         col(col_),
+         text(text_),
+         type(type_)
+    {}
+    PError(const PError& other)
+        :lineno(other.lineno),
+         col(other.col),
+         text(other.text),
+         type(other.type)
+    {}
+
+    void setErrorDetail(int lineno_, int col_, ErrorType type_, const char* fmt, ...) {
+        lineno = lineno_;
+        col = col_;
+        type = type_;
+        
+        va_list va;
+        va_start(va, fmt);
+        char fullstr[BUFSIZE];
+        vsnprintf(fullstr, BUFSIZE, fmt, va);
+        va_end(va);
+        text = std::string(fullstr);
+    }
+
+    void setErrorText(const char* fmt, ...) {
+        va_list va;
+        va_start(va, fmt);
+        char fullstr[BUFSIZE];
+        vsnprintf(fullstr, BUFSIZE, fmt, va);
+        va_end(va);
+        text = std::string(fullstr);
+    }
+
+    inline void clear() {
+        lineno = -1;
+        col = -1;
+        text = "";
+        type = ET_SUC;
+    }
+
+    int lineno;
+    int col;
+    std::string text;
+    ErrorType type;
+};
+
+}
+#endif
diff --git a/libjconer/include/jconer/json.hpp b/libjconer/include/jconer/json.hpp
new file mode 100644
index 0000000..b61d29e
--- /dev/null
+++ b/libjconer/include/jconer/json.hpp
@@ -0,0 +1,34 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_JSON_HPP__
+#define __JCONER_JSON_HPP__
+
+#include "jconer/token.hpp"
+#include "jconer/value.hpp"
+#include "jconer/stream.hpp"
+#include "jconer/parser.hpp"
+#include "jconer/dump.hpp"
+#include "jconer/error.hpp"
+#include "jconer/serializer.hpp"
+
+#endif
diff --git a/libjconer/include/jconer/parser.hpp b/libjconer/include/jconer/parser.hpp
new file mode 100644
index 0000000..9148ac6
--- /dev/null
+++ b/libjconer/include/jconer/parser.hpp
@@ -0,0 +1,69 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_PARSER_HPP__
+#define __JCONER_PARSER_HPP__
+
+#include "jconer/token.hpp"
+#include "jconer/value.hpp"
+#include "jconer/stream.hpp"
+#include "jconer/error.hpp"
+#include "common/logging.hpp"
+
+namespace JCONER {
+
+class Parser {
+    public:
+        Parser();
+        Parser(IStream& instream);
+        
+        JValue* parse();
+        JValue* parse(IStream& instream);
+        JValue* parseFromFile(std::string filename);
+        inline PError error() const { return _err;}
+    private:
+        IStream* _instream;
+        Token _cur_token;
+        PError _err;
+ 
+        void _getNextToken();
+        JValue* _parseValue();
+        JValue* _parseInt();
+        JValue* _parseString();
+        JValue* _parseReal();
+        JValue* _parseTrue();
+        JValue* _parseFalse();
+        JValue* _parseNull();
+        JValue* _parseArray();
+        JValue* _parseObject();
+
+        inline bool _checkTokenType(TokenType type) const { return _cur_token.type() == type;}
+};
+
+JValue* load(std::string filename, PError& err);
+JValue* load(const char* filename, PError& err);
+JValue* loads(const char* buffer, PError& err);
+JValue* loads(std::string buffer, PError& err);
+
+}
+
+#endif
diff --git a/libjconer/include/jconer/serializer.hpp b/libjconer/include/jconer/serializer.hpp
new file mode 100644
index 0000000..3f7bfb4
--- /dev/null
+++ b/libjconer/include/jconer/serializer.hpp
@@ -0,0 +1,294 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_OBJECT_HPP__
+#define __JCONER_OBJECT_HPP__
+
+#include "jconer/value.hpp"
+#include <map>
+#include <set>
+#include <list>
+#include <vector>
+#include <cassert>
+
+namespace JCONER {
+
+
+class SerializeFailException : public std::exception {
+  public:
+    const char* what() const throw() {
+      return "Serialize Failed";
+    }
+};
+
+class OutSerializer {
+    public:
+        OutSerializer() {
+            clear(); 
+        }
+
+        JValue* getContent() { return _array; }
+
+        std::string getText() {
+            std::string jsonText = dumps(_array);
+            return jsonText;
+        }
+
+        void clear() {
+          _array = new JArray();
+          _curr = _array;
+        }
+
+        template<class Type>
+        void operator&(Type& value) {
+            JArray* item = new JArray();
+            JArray* old_curr = _curr;
+            _curr->append(item);
+            _curr = item;
+
+            value.serialize(*this);
+            _curr = old_curr;
+        }
+
+        template<template<class T, class Allocator> class Container, class ValueType>
+        void operator&(Container<ValueType, std::allocator<ValueType> >& value) {
+            JArray* item = new JArray();
+            JArray* old_curr = _curr;
+            _curr->append(item);
+            _curr = item;
+
+            for(typename Container<ValueType, std::allocator<ValueType> >::iterator iter = value.begin();
+                    iter != value.end(); iter ++) {
+                *this & *iter;
+            }
+            _curr = old_curr;
+        }
+
+        template<class K, class V>
+        void operator&(std::pair<K, V>& value) {
+            JArray* item = new JArray();
+            JArray* old_curr = _curr;
+            _curr->append(item);
+            _curr = item;
+
+            *this & value.first;
+            *this & value.second;
+            _curr = old_curr;
+        }
+
+        template<class K, class V>
+        void operator&(std::map<K,V>& value) {
+            JArray* item = new JArray();
+            JArray* old_curr = _curr;
+            _curr->append(item);
+            _curr = item;
+
+            for(typename std::map<K, V>::iterator iter = value.begin();
+                    iter != value.end(); iter ++) {
+                *this & *iter;
+            }
+            _curr = old_curr;
+        }
+
+        void operator&(const int value) {
+            _curr->append(value);
+        }
+
+        void operator&(const long value) {
+            _curr->append(value);
+        }
+
+        void operator&(const std::string value) {
+            _curr->append(value);
+        }
+
+        void operator&(const bool value) {
+            _curr->append(value);
+        }
+
+        void operator&(const char* value) {
+            _curr->append(value);
+        }
+
+        void operator&(const double value) {
+            _curr->append(value);
+        }
+
+        void operator&(const float value) {
+            _curr->append(value);
+        }
+
+
+    private:
+        JArray* _array;
+        JArray* _curr;
+};
+
+
+class InSerializer {
+    public:
+        InSerializer(JValue* array) {
+            assert(array->isArray());
+            _array = (JArray*)array;
+            _curr = _array;
+            _index = 0;
+        }
+
+        InSerializer(std::string jsonText) {
+          PError err;
+          JValue * array = loads(jsonText, err);
+          assert(array != NULL && array->isArray());
+
+          _array = (JArray*)array;
+          _curr = _array;
+          _index = 0;
+        }
+
+        template<class Type>
+        void operator&(Type& value) {
+            _check();
+            JArray* old_curr = _curr;
+            _curr = (JArray*)_curr->get(_index);
+
+            int old_index = _index;
+            _index = 0;
+            
+            value.serialize(*this);
+
+            _curr = old_curr;
+            _index = old_index + 1;
+        }
+
+        template<template<class T, class Allocator> class Container, class ValueType>
+        void operator&(Container<ValueType, std::allocator<ValueType> >& value) {
+            _check();
+            value.clear();
+            JArray* old_curr  = _curr;
+            _curr = (JArray*)_curr->get(_index);
+
+            int old_index = _index;
+            _index = 0;
+
+            for(int i = 0; i < _curr->size(); i ++) {
+                ValueType tmp;
+                value.push_back(tmp);
+            }
+
+            for(typename Container<ValueType, std::allocator<ValueType> >::iterator iter = value.begin();
+                    iter != value.end(); iter ++) {
+                *this & *iter;
+            }
+            _curr = old_curr;
+            _index = old_index + 1;
+        }
+
+        template<class K, class V>
+        void operator&(std::pair<K, V>& value) {
+            _check();
+            JArray* old_curr  = _curr;
+            _curr = (JArray*)_curr->get(_index);
+
+            int old_index = _index;
+            _index = 0;
+
+            *this & value.first;
+            *this & value.second;
+
+            _curr = old_curr;
+            _index = old_index + 1;
+
+        }
+
+        template<class K, class V>
+        void operator&(std::map<K,V>& value) {
+            _check();
+            value.clear();
+            JArray* old_curr  = _curr;
+            _curr = (JArray*)_curr->get(_index);
+
+            int old_index = _index;
+            _index = 0;
+
+            for(int i = 0; i < _curr->size(); i ++) {
+                K k;
+                V v;
+                std::pair<K, V> p = std::make_pair(k, v);
+                *this & p;
+                value.insert(p);
+            }
+
+            _curr = old_curr;
+            _index = old_index + 1;
+        }
+
+
+        void operator&(int& value) {
+            _check();
+            value = _curr->get(_index)->getInteger();
+            _index ++;
+        }
+
+        void operator&(long& value) {
+            _check();
+            value = _curr->get(_index)->getInteger();
+            _index ++;
+        }
+
+        void operator&(std::string& value) {
+            _check();
+            value = _curr->get(_index)->getString();
+            _index ++;
+        }
+
+        void operator&(bool& value) {
+            _check();
+            if (_curr->get(_index)->isTrue())
+                value = true;
+            else
+                value = false;
+            _index ++;
+        }
+
+        void operator&(double& value) {
+            _check();
+            value = _curr->get(_index)->getReal();
+            _index ++;
+        }
+
+        void operator&(float& value) {
+            _check();
+            value = _curr->get(_index)->getReal();
+            _index ++;
+        }
+    private:
+        JArray* _array;
+        JArray* _curr;
+        int _index;
+
+        inline void _check() {
+          if (_index >= _curr->size()) {
+            throw SerializeFailException();
+          }
+        }
+};
+}
+#endif
diff --git a/libjconer/include/jconer/stream.hpp b/libjconer/include/jconer/stream.hpp
new file mode 100644
index 0000000..fddfd8a
--- /dev/null
+++ b/libjconer/include/jconer/stream.hpp
@@ -0,0 +1,64 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_STREAM_HPP__
+#define __JCONER_STREAM_HPP__
+
+#include "jconer/token.hpp"
+#include "common/logging.hpp"
+#include "jconer/error.hpp"
+
+#include <istream>
+#include <fstream>
+
+
+namespace JCONER {
+
+class IStream {
+    public:
+        IStream(std::istream& _fin);
+        virtual Token getNextToken();
+        inline PError error() const { return _err; }
+        virtual ~IStream();
+    private:
+        int _getLength();
+        int _getRemainingLength();
+
+        int _getNextChar();
+        void _ungetChar();
+        bool _stripWhitespace();
+        int _readBuffer();
+        int _getNChar(char* str, int n);
+
+        std::istream& _fin;
+        int _lineno;
+        int _col;
+        char* _buff;
+        char* _end;
+        char* _cur;
+        int _cur_pos;
+        int _content_length;
+        PError _err;
+};
+
+}
+#endif
diff --git a/libjconer/include/jconer/token.hpp b/libjconer/include/jconer/token.hpp
new file mode 100644
index 0000000..e8f86ef
--- /dev/null
+++ b/libjconer/include/jconer/token.hpp
@@ -0,0 +1,91 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_TOKEN_HPP__
+#define __JCONER_TOKEN_HPP__
+
+#include <string>
+#include "common/all.hpp"
+using namespace COMMON;
+
+namespace JCONER {
+
+enum TokenType {
+    TT_ARRAY_OPEN_BRACE = 0,
+    TT_ARRAY_CLOSE_BRACE,
+    TT_OBJECT_OPEN_BRACE,
+    TT_OBJECT_CLOSE_BRACE,
+
+    TT_COMMA,
+    TT_COLON,
+
+    TT_STRING,
+    TT_INTEGER,
+    TT_REAL,
+
+    TT_TRUE,
+    TT_FALSE,
+    TT_NULL,
+
+    TT_END, // end of file
+
+    TT_INVALID
+};
+
+class Token {
+    public:
+        Token(TokenType type)
+            :_type(type), _lineno(-1), _col(-1)
+        {
+        }
+        Token(TokenType type, int lineno, int col, std::string text)
+            : _type(type), _lineno(lineno), _col(col), _text(text)
+        {
+            LOG(DEBUG) << "Generate a new token[" << toString() << "] at [" << _lineno << "|" << _col << "]" << std::endl;
+        }
+        Token(TokenType type, int lineno, int col, char c)
+            : _type(type), _lineno(lineno), _col(col), _text(1, c)
+        {
+            LOG(DEBUG) << "Generate a new token[" << toString() << "] at [" << _lineno << "|" << _col << "]" << std::endl;
+        }
+
+        Token(const Token& t)
+            : _type(t._type), _lineno(t._lineno), _col(t._col), _text(t._text)
+        {
+        }
+
+        inline TokenType type() const { return _type; }
+        inline int lineno() const { return _lineno; }
+        inline int col() const { return _col;}
+        inline std::string text() const { return _text; }
+        static TokenType getTokenOne(char c);
+        std::string toString();
+    private:
+        TokenType _type;
+        int _lineno;
+        int _col;
+        std::string _text;
+};
+
+
+}
+#endif
diff --git a/libjconer/include/jconer/util.hpp b/libjconer/include/jconer/util.hpp
new file mode 100644
index 0000000..ff7f3df
--- /dev/null
+++ b/libjconer/include/jconer/util.hpp
@@ -0,0 +1,131 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_UTIL_HPP__
+#define __JCONER_UTIL_HPP__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <string>
+
+namespace JCONER {
+
+class HexCode {
+    public:
+        static int32_t decode(const char* str) {
+            int32_t value = 0;
+            for(int i = 0; i < 4; i ++ ) {
+                value <<= 4;
+                char c = str[i];
+                if (isdigit(c)){
+                    value += c - '0';
+                } else if ('A' <= c && c <= 'F') { 
+                    value += c - 'A' + 10;
+                } else if ('a' <=c && c <= 'f') {
+                    value += c - 'a' + 10;
+                } else {
+                    return -1;
+                }
+            }
+            return value;
+        }
+};
+
+class UTF8 {
+    public:
+        static int encode(int32_t value, char* str, int n) {
+            if (value < 0 || n <= 0)
+                return -1;
+            if (value < 0x80) {
+                str[0] = (char)value;
+                return 1;
+            }
+            if (value < 0x800) {
+                if (n < 2) return -1;
+                str[0] = 0xC0 + ((value & 0x7C0) >> 6);
+                str[1] = 0x80 + ((value & 0x03F));
+                return 2;
+            }
+            if (value < 0x10000) {
+                if (n < 3) return -1;
+                str[0] = 0xE0 + ((value & 0XF000) >> 12);
+                str[1] = 0x80 + ((value & 0x0FC0) >> 6);
+                str[2] = 0x80 + ((value & 0x003F));
+                return 3;
+            }
+            if (value <= 0x10FFFF) {
+                if (n < 4) return -1;
+                str[0] = 0xF0 + ((value & 0x1C0000) >> 18);
+                str[1] = 0x80 + ((value & 0x03F000) >> 12);
+                str[2] = 0x80 + ((value & 0x000FC0) >> 6);
+                str[3] = 0x80 + ((value & 0x00003F));
+                return 4;
+            }
+            return -1;
+        }
+    
+        static int decode(const char* p, int32_t* hex) {
+            int count = getUTF8Length(p);
+            if (count  == 0) {
+                return 0;
+            }
+            if (count == 1) {
+                *hex = (int32_t)*p;
+            } else {
+                int32_t value = 0;
+                unsigned char u = (unsigned char)*p;
+
+                if (count == 2) value = u & 0x1F;
+                else if (count == 3) value = u & 0xF;
+                else value = u & 0x7;
+
+                for (int i = 1; i < count; i ++ ) {
+                    u = (unsigned char)p[i];
+                    if (u < 0x80 || u > 0xBF) return 0;
+                    value = (value << 6) + (u & 0x3F);
+                }
+
+                if (value > 0x10FFFF) return 0;
+                if (0xD800 <= value && value <= 0xDFFF) return 0;        
+                if ((count == 2 && value < 0x80) ||
+                    (count == 3 && value < 0x800) ||
+                    (count == 4 && value < 0x10000)) return 0;
+                *hex = value;
+            }
+            return count;
+        }
+    private:
+        static int getUTF8Length(const char* p) {
+            unsigned char byte = (unsigned char)*p;
+            if (byte < 0x80) return 1;
+            if (0x80 <= byte && byte <= 0xBF) return 0;
+            if (byte == 0xC0 || byte == 0xC1) return 0;
+            if (0xC2 <= byte && byte <= 0xDF) return 2;
+            if (0xE0 <= byte && byte <= 0xEF) return 3;
+            if (0xF0 <= byte && byte <= 0xF4) return 4;
+            return 0;
+        }
+};
+
+}
+#endif
diff --git a/libjconer/include/jconer/value.hpp b/libjconer/include/jconer/value.hpp
new file mode 100644
index 0000000..d69f260
--- /dev/null
+++ b/libjconer/include/jconer/value.hpp
@@ -0,0 +1,254 @@
+// The MIT License (MIT)
+//
+// Copyright (c) 2014 Justin (Jianfeng) Lin
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef __JCONER_VALUE_HPP__
+#define __JCONER_VALUE_HPP__
+
+#include <string>
+#include <map>
+#include <vector>
+#include "jconer/allocator.hpp"
+
+#include "common/logging.hpp"
+#define NULL_VALUE 0
+
+namespace JCONER {
+
+typedef int NULL_TYPE;
+
+enum ValueType {
+    VT_OBJECT = 0,
+    VT_ARRAY,
+    VT_INTEGER,
+    VT_STRING,
+    VT_REAL,
+    VT_TRUE,
+    VT_FALSE,
+    VT_NULL
+};
+
+enum InsertError {
+    IE_SUC = 0,
+    IE_SELF,
+    IE_NULL
+};
+
+class JValue {
+    public:
+        JValue(ValueType type);
+        inline ValueType type() { return _type; }
+        virtual ~JValue();
+        virtual JValue* deepcopy() = 0;
+        virtual void printout() = 0;
+
+        static inline bool isString(const JValue* value) { return value->_type == VT_STRING;}
+        static inline bool isInteger(const JValue* value) { return value->_type == VT_INTEGER;}
+        static inline bool isReal(const JValue* value) { return value->_type == VT_REAL;}
+        static inline bool isTrue(const JValue* value) { return value->_type == VT_TRUE;}
+        static inline bool isFalse(const JValue* value) { return value->_type == VT_FALSE;}
+        static inline bool isNull(const JValue* value) { return value->_type == VT_NULL;}
+        static inline bool isObject(const JValue* value) { return value->_type == VT_OBJECT;}
+        static inline bool isArray(const JValue* value) { return value->_type == VT_ARRAY;}
+
+        inline bool isString() { return _type == VT_STRING; }
+        inline bool isInteger() { return _type == VT_INTEGER; }
+        inline bool isReal() { return _type == VT_REAL; }
+        inline bool isTrue() { return _type == VT_TRUE; }
+        inline bool isFalse() { return _type == VT_FALSE; }
+        inline bool isNull() { return _type == VT_NULL;}
+        inline bool isObject() { return _type == VT_OBJECT; }
+        inline bool isArray() { return _type == VT_ARRAY; }
+
+        std::string getString();
+        long getInteger();
+        bool getBool();
+        double getReal();
+
+        JValue* get(size_t i);
+        JValue* get(std::string key);
+        int size();
+        std::vector<std::string> getKeys();
+        bool contain(std::string key);
+#if false
+        void* operator new(size_t size) throw (std::bad_alloc) {
+            return allocate(size);
+        }
+
+        void operator delete(void* ptr) throw () {            
+        }
+#endif
+
+    protected:
+        ValueType _type;
+};
+
+class JNull : public  JValue {
+    public:
+        static JNull* getInstance() {
+            return &_instance;
+        }
+        inline NULL_TYPE getValue() { return NULL_VALUE; }
+        void printout();
+        JValue* deepcopy();
+    private:
+        JNull();
+        static JNull _instance;
+};
+
+class JInt : public JValue {
+    public:
+        JInt(const long value);
+        inline long getValue() { return _value; }
+        void printout();
+        JValue* deepcopy();
+    private:
+        long _value;
+};
+
+class JReal : public JValue {
+    public:
+        JReal(const double value);
+        inline double getValue() { return _value; }
+        void printout();
+        JValue* deepcopy();
+    private:
+        double _value;
+};
+
+class JString : public JValue {
+    public:
+        JString(const std::string value);
+        JString(const char* str);
+        inline std::string getValue() { return _value; }
+        std::string getAsciiValue();
+        void printout();
+        JValue* deepcopy();
+    private:
+        std::string _value;
+};
+
+class JTrue : public JValue {
+    public:
+        static JTrue* getInstance() {
+            return &_instance;
+        }
+        inline bool getValue() { return true; }
+        void printout();
+        JValue* deepcopy();
+        JTrue();
+    private:
+        //JTrue();
+        static JTrue _instance;
+};
+
+class JFalse : public JValue {
+    public:
+        static JFalse* getInstance() {
+            return &_instance;
+        }
+        inline bool getValue() { return true; }
+        void printout();
+        JValue* deepcopy();
+        JFalse();
+    private:
+        //JFalse();
+        static JFalse _instance;
+};
+
+class JArray : public JValue {
+    public:
+        JArray();
+        JArray(const std::vector<JValue*>& array);
+        ~JArray();
+
+        inline std::vector<JValue*> getArray() { return _array; }
+        inline int size() { return _array.size(); }
+        void printout();
+        inline JValue* get(size_t i) {
+            if (i < _array.size())
+                return _array[i];
+            else
+                return NULL;
+        }
+
+        InsertError append(JValue* element);
+        void append(const long value);
+        void append(const size_t value);
+        void append(const int value);
+        void append(const std::string value);
+        void append(const char* str);
+        void append(const bool value);
+        void append(const double value);
+        void appendNull();
+
+        JValue* pop_back();
+        JValue* pop(size_t i);
+        JValue* deepcopy();
+    private:
+        std::vector<JValue*> _array;
+};
+
+class JObject : public JValue {
+    public:
+        JObject();
+        JObject(const std::map<std::string, JValue*>& object);
+        ~JObject();
+
+        inline std::map<std::string, JValue*> getObject() { return _object; }
+        inline int size() { return _object.size(); }
+        void printout();
+        inline bool contain(std::string key) {
+            if (_object.find(key) != _object.end()) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        inline JValue* get(std::string key) {
+            if (_object.find(key) != _object.end()) {
+                return _object[key];
+            } else {
+                return NULL;
+            }
+        }
+
+        std::vector<std::string> getKeys();
+
+        InsertError put(const std::string, JValue*); 
+        void put(const std::string, const long);
+        void put(const std::string, const size_t);
+        void put(const std::string, const int);
+        void put(const std::string, const std::string);
+        void put(const std::string, const char*);
+        void put(const std::string, const bool);
+        void put(const std::string, const double);
+        void put(const std::string);
+        JValue* pop(std::string key);
+        JValue* deepcopy();
+    private:
+        std::map<std::string, JValue*> _object;
+};
+
+}
+
+#endif
diff --git a/libjconer/src/allocator.cpp b/libjconer/src/allocator.cpp
new file mode 100755
index 0000000..1f91bdd
--- /dev/null
+++ b/libjconer/src/allocator.cpp
@@ -0,0 +1,12 @@
+#include <iostream>
+#include "jconer/allocator.hpp"
+
+Allocator alloc;
+
+void* allocate(size_t size) /*throw (std::bad_alloc)*/ {
+  void* ptr = alloc.malloc(size);
+  /*if (ptr == NULL) {
+    throw std::bad_alloc();
+  }*/
+  return ptr;
+}
diff --git a/libjconer/src/arena.cpp b/libjconer/src/arena.cpp
new file mode 100755
index 0000000..d02ef2e
--- /dev/null
+++ b/libjconer/src/arena.cpp
@@ -0,0 +1,182 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include "jconer/arena.hpp"
+
+#define DEFAULT_BLOCK_SIZE 8192
+#define ALIGNMENT               8
+#define ALIGNMENT_MASK          (ALIGNMENT - 1)
+#define ROUNDUP(x)              (((x) + ALIGNMENT_MASK) & ~ALIGNMENT_MASK)
+
+typedef struct _block {
+    /* Total number of bytes owned by this block available to pass out.
+     * Read-only after initialization.  The first such byte starts at
+     * ab_mem.
+     */
+    size_t ab_size;
+
+    /* Total number of bytes already passed out.  The next byte available
+     * to pass out starts at ab_mem + ab_offset.
+     */
+    size_t ab_offset;
+
+    /* An arena maintains a singly-linked, NULL-terminated list of
+     * all blocks owned by the arena.  These are linked via the
+     * ab_next member.
+     */
+    struct _block *ab_next;
+
+    /* Pointer to the first allocatable byte owned by this block.  Read-
+     * only after initialization.
+     */
+    void *ab_mem;
+} block;
+
+/* The arena manages two kinds of memory, blocks of raw memory
+   and a list of PyObject* pointers.  PyObjects are decrefed
+   when the arena is freed.
+*/
+
+struct _arena {
+    /* Pointer to the first block allocated for the arena, never NULL.
+       It is used only to find the first block when the arena is
+       being freed.
+     */
+    block *a_head;
+
+    /* Pointer to the block currently used for allocation.  It's
+       ab_next field should be NULL.  If it is not-null after a
+       call to block_alloc(), it means a new block has been allocated
+       and a_cur should be reset to point it.
+     */
+    block *a_cur;
+
+#if defined(_DEBUG)
+    /* Debug output */
+    size_t total_allocs;
+    size_t total_size;
+    size_t total_blocks;
+    size_t total_block_size;
+    size_t total_big_blocks;
+#endif
+};
+
+static block *
+block_new(size_t size)
+{
+    /* Allocate header and block as one unit.
+       ab_mem points just past header. */
+    block *b = (block *)malloc(sizeof(block) + size);
+    if (!b)
+        return NULL;
+    b->ab_size = size;
+    b->ab_mem = (void *)(b + 1);
+    b->ab_next = NULL;
+    b->ab_offset = ROUNDUP((long)(b->ab_mem)) -
+      (long)(b->ab_mem);
+    return b;
+}
+
+static void
+block_free(block *b) {
+    while (b) {
+        block *next = b->ab_next;
+        free(b);
+        b = next;
+    }
+}
+
+static void *
+block_alloc(block *b, size_t size)
+{
+    void *p;
+    assert(b);
+    size = ROUNDUP(size);
+    if (b->ab_offset + size > b->ab_size) {
+        /* If we need to allocate more memory than will fit in
+           the default block, allocate a one-off block that is
+           exactly the right size. */
+        /* TODO(jhylton): Think about space waste at end of block */
+        block *newbl = block_new(
+                        size < DEFAULT_BLOCK_SIZE ?
+                        DEFAULT_BLOCK_SIZE : size);
+        if (!newbl)
+            return NULL;
+        assert(!b->ab_next);
+        b->ab_next = newbl;
+        b = newbl;
+    }
+
+    assert(b->ab_offset + size <= b->ab_size);
+    p = (void *)(((char *)b->ab_mem) + b->ab_offset);
+    b->ab_offset += size;
+    return p;
+}
+
+Arena *
+arena_New()
+{
+    Arena* arena = (Arena *)malloc(sizeof(Arena));
+    if (!arena)
+        return NULL;
+
+    arena->a_head = block_new(DEFAULT_BLOCK_SIZE);
+    arena->a_cur = arena->a_head;
+    if (!arena->a_head) {
+        free((void *)arena);
+        return NULL;
+    }
+
+#if defined(_DEBUG)
+    arena->total_allocs = 0;
+    arena->total_size = 0;
+    arena->total_blocks = 1;
+    arena->total_block_size = DEFAULT_BLOCK_SIZE;
+    arena->total_big_blocks = 0;
+#endif
+    return arena;
+}
+
+void
+arena_Free(Arena *arena)
+{
+    assert(arena);
+#if defined(_DEBUG)
+    /*
+    fprintf(stderr,
+        "alloc=%d size=%d blocks=%d block_size=%d big=%d objects=%d\n",
+        arena->total_allocs, arena->total_size, arena->total_blocks,
+        arena->total_block_size, arena->total_big_blocks,
+        PyList_Size(arena->a_objects));
+    */
+#endif
+    block_free(arena->a_head);
+    /* This property normally holds, except when the code being compiled
+       is sys.getobjects(0), in which case there will be two references.
+    */
+    free(arena);
+}
+
+void *
+arena_Malloc(Arena *arena, size_t size)
+{
+    void *p = block_alloc(arena->a_cur, size);
+    if (!p)
+        return NULL;
+#if defined(_DEBUG)
+    arena->total_allocs++;
+    arena->total_size += size;
+#endif
+    /* Reset cur if we allocated a new block. */
+    if (arena->a_cur->ab_next) {
+        arena->a_cur = arena->a_cur->ab_next;
+#if defined(_DEBUG)
+        arena->total_blocks++;
+        arena->total_block_size += arena->a_cur->ab_size;
+        if (arena->a_cur->ab_size > DEFAULT_BLOCK_SIZE)
+            ++arena->total_big_blocks;
+#endif
+    }
+    return p;
+}
diff --git a/libjconer/src/dump.cpp b/libjconer/src/dump.cpp
new file mode 100755
index 0000000..bcea12d
--- /dev/null
+++ b/libjconer/src/dump.cpp
@@ -0,0 +1,141 @@
+#include "jconer/util.hpp"
+#include "jconer/dump.hpp"
+#include "common/all.hpp"
+#include <fstream>
+#include <sstream>
+#include <algorithm>
+
+namespace JCONER {
+
+static void dumpInner(JValue* value, std::ostream& out, int flag, int indent) {
+    bool pretty_print = flag & DUMP_PRETTY_PRINT;
+    bool sort_key = flag & DUMP_SORT_KEY;
+    bool ensure_ascii = flag & DUMP_ENSURE_ASCII;
+    bool compact_print = flag & DUMP_COMPACT_PRINT;
+    
+    switch(value->type()) {
+        case VT_INTEGER:
+            out << ((JInt*)value)->getValue();
+            break;
+        case VT_REAL:
+            out << ((JReal*)value)->getValue();
+            break;
+        case VT_TRUE:
+            out << "true";
+            break;
+        case VT_FALSE:
+            out << "false";
+            break;
+        case VT_NULL:
+            out << "null";
+            break;
+        case VT_STRING:
+            if (ensure_ascii) {
+                out << '"' << ((JString*)value)->getAsciiValue() << '"';
+            } else {
+                out << '"' << ((JString*)value)->getValue() << '"';
+            }
+            break;
+        case VT_OBJECT:
+            {
+            JObject* ovalue = (JObject*) value;
+            std::vector<std::string> keys = ovalue->getKeys();
+            if (sort_key) {
+                std::sort(keys.begin(), keys.end());
+            }
+            
+            out << "{";
+            
+            for (size_t i = 0; i < keys.size(); i ++ ) {
+                if (! compact_print) {
+                    if (pretty_print) {
+                        out << std::endl;
+                        std::string indent_string(indent, ' ');
+                        out << indent_string;
+                    }
+                    else out << " ";
+                }
+
+                out << "\"" << keys[i] << "\"";
+                if (compact_print) {
+                  out << ":";
+                } else {
+                  out << " : ";
+                }
+                dumpInner(ovalue->get(keys[i]), out, flag, indent + DUMP_INDENT);
+                if (i != keys.size() - 1) {
+                    out << ",";
+                }
+            }
+            if (! compact_print) {
+                if (pretty_print) {
+                    out << std::endl;
+                    std::string indent_string(indent - DUMP_INDENT, ' ');
+                    out << indent_string;
+                }
+                else out << " ";
+            }
+            
+            out << "}";
+            }
+            break;
+        case VT_ARRAY:
+            {
+            JArray* avalue = (JArray*) value;
+            out << "[";
+            for (int i = 0; i < avalue->size(); i ++ ) {
+                if (!compact_print) {
+                    if (pretty_print) {
+                        out << std::endl;
+                        std::string indent_string(indent, ' ');
+                        out << indent_string;
+                    } else out << " ";
+                }
+
+                dumpInner(avalue->get(i), out, flag, indent + DUMP_INDENT);
+                if (i != avalue->size() - 1) {
+                    out  << ",";
+                }
+            }
+            if (!compact_print) {
+                if (pretty_print) {
+                    out << std::endl;
+                    std::string indent_string(indent - DUMP_INDENT, ' ');
+                    out << indent_string;
+                }
+                else out << " ";
+            }
+            
+            out << "]";
+            }
+            break;
+    }
+}
+
+void dump(JValue* value, std::ostream& out, int flag) {
+    dumpInner(value, out, flag, DUMP_INDENT);
+}
+
+void dumpFile(JValue* value, std::string filename, int flag) {
+    std::ofstream fout(filename.c_str()); 
+    dump(value, fout, flag);
+    fout.close();
+}
+
+std::string dumps(JValue* value, int flag) {
+    std::stringstream ssout;
+    dump(value, ssout, flag);
+    std::string jsonString = ssout.str();
+    return jsonString;
+}
+
+void dumps(JValue* value, char** pbuffer, int flag) {
+    std::stringstream ssout;
+    dump(value, ssout, flag);
+    std::string jsonString = ssout.str();
+    int strSize = jsonString.size();
+    MALLOC(char, *pbuffer, strSize + 1);
+    strncpy(*pbuffer, jsonString.c_str(), strSize + 1);
+}
+
+}
diff --git a/libjconer/src/parser.cpp b/libjconer/src/parser.cpp
new file mode 100755
index 0000000..b4eed8e
--- /dev/null
+++ b/libjconer/src/parser.cpp
@@ -0,0 +1,218 @@
+#include "jconer/parser.hpp"
+#include <stdlib.h>
+#include <inttypes.h>
+#include <string.h>
+#include <errno.h>
+#include <sstream>
+
+namespace JCONER {
+
+Parser::Parser()
+    :_instream(NULL), _cur_token(TT_END)
+{
+}
+
+Parser::Parser(IStream& instream)
+    :_instream(&instream), _cur_token(TT_END)
+{
+}
+
+JValue* Parser::parse() {
+    _getNextToken();
+    return _parseValue();
+}
+
+JValue* Parser::parse(IStream& instream) {
+    _instream = &instream;
+    _getNextToken();
+    return _parseValue();
+}
+
+JValue* Parser::parseFromFile(std::string filename) {
+    std::ifstream in(filename.c_str());
+    IStream fin(in);
+    _instream = &fin;
+    return parse();
+}
+
+void Parser::_getNextToken() {
+    if (_instream == NULL) {
+        LOG(FATAL) << "There is no stream" << std::endl;
+    }
+    _cur_token = _instream->getNextToken(); 
+}
+
+JValue* Parser::_parseValue() {
+    switch(_cur_token.type()) {
+        case TT_STRING:
+            return _parseString();
+        case TT_INTEGER:
+            return _parseInt();
+        case TT_REAL:
+            return _parseReal();
+        case TT_TRUE:
+            return _parseTrue();
+        case TT_FALSE:
+            return _parseFalse();
+        case TT_NULL:
+            return _parseNull();
+        case TT_ARRAY_OPEN_BRACE:
+            return _parseArray();
+        case TT_OBJECT_OPEN_BRACE:
+            return _parseObject();
+        default:
+            _err = _instream->error();
+            return NULL;
+    }
+}
+
+JValue* Parser::_parseInt() {
+    long value = strtol(_cur_token.text().c_str(), NULL, 10);
+    if (errno == ERANGE) {
+        _err.setErrorDetail(_cur_token.lineno(), _cur_token.col(), ET_PARSE_RANGE, "Value ouf of range[%s]\n", _cur_token.text().c_str());
+        return NULL;
+    }
+    return new JInt(value); 
+}
+
+JValue* Parser::_parseString() {
+    return new JString(_cur_token.text());
+}
+
+JValue* Parser::_parseReal() {
+    double value = strtod(_cur_token.text().c_str(), NULL);
+    if (errno == ERANGE) {
+        _err.setErrorDetail(_cur_token.lineno(), _cur_token.col(), ET_PARSE_RANGE, "Value ouf of range[%s]\n", _cur_token.text().c_str());
+        return NULL;
+    }
+    return new JReal(value);
+}
+
+JValue* Parser::_parseTrue() {
+    return JTrue::getInstance();
+}
+
+JValue* Parser::_parseFalse() {
+    return JFalse::getInstance();
+}
+
+JValue* Parser::_parseNull() {
+    return JNull::getInstance();;
+}
+
+JValue* Parser::_parseArray() {
+    _getNextToken();
+    JValue* rst = new JArray();
+    JValue* elt = NULL;
+    
+    if (_cur_token.type() == TT_ARRAY_CLOSE_BRACE) 
+        return rst;
+
+    while(true) {
+        elt = _parseValue();
+        ((JArray*)rst)->append(elt);
+        _getNextToken();
+        switch(_cur_token.type()) {
+            case TT_COMMA:
+                _getNextToken();
+                break;
+            case TT_ARRAY_CLOSE_BRACE:
+                return rst;
+            default:
+                _err.setErrorDetail(_cur_token.lineno(),
+                                    _cur_token.col(),
+                                    ET_PARSE_UNEXPECTED_TOKEN,
+                                    "Unexpected token while parsing array\n",
+                                    _cur_token.text().c_str());
+                return NULL;
+        }
+    }   
+    return rst;
+}
+
+JValue* Parser::_parseObject() {
+    JValue* rst = new JObject();
+
+    JValue* value = NULL;
+    std::string key;
+
+    _getNextToken();
+    if(_cur_token.type() == TT_OBJECT_CLOSE_BRACE) {
+        return rst;
+    }
+
+    while(true) {
+        if (!_checkTokenType(TT_STRING) ) {
+            goto fail;
+        }
+        key = _cur_token.text();
+
+        _getNextToken();
+        if (!_checkTokenType(TT_COLON)) {
+            goto fail;
+        }
+
+        _getNextToken();
+        value = _parseValue();
+        ((JObject*)rst)->put(key, value);
+
+        _getNextToken();
+        switch(_cur_token.type()) {
+            case TT_COMMA:
+                _getNextToken();
+                break;
+            case TT_OBJECT_CLOSE_BRACE:
+                return rst;
+            default:
+                goto fail;
+        }
+    }
+    return rst;
+fail:
+    _err.setErrorDetail(_cur_token.lineno(),
+                        _cur_token.col(),
+                        ET_PARSE_UNEXPECTED_TOKEN,
+                        "Unexpected token while parsing object\n",
+                        _cur_token.text().c_str());
+    return NULL;
+
+}
+
+JValue* load(std::string filename, PError& err) {
+    std::ifstream in(filename.c_str());
+    if (!in.good()) {
+        err.type = ET_IO_FILE_NOT_FOUND;
+        return NULL;
+    }
+    IStream fin(in);
+    Parser parser(fin);
+    JValue* rst = parser.parse();
+    if (rst == NULL) {
+        err = parser.error();
+    }
+    in.close();
+    return rst;
+}
+
+JValue* load(const char* filename, PError& err) {
+    std::string str_filename(filename);
+    return load(str_filename, err);
+}
+
+JValue* loads(const char* buffer, PError& err) {
+    std::string str_buffer(buffer);
+    return loads(str_buffer, err);
+}
+
+JValue* loads(std::string buffer, PError& err) {
+    std::stringstream ssin(buffer);
+    IStream fin(ssin);
+    Parser parser(fin);
+    JValue* rst = parser.parse();
+    if (rst == NULL) {
+        err = parser.error();
+    }
+    return rst;
+}
+
+}
diff --git a/libjconer/src/stream.cpp b/libjconer/src/stream.cpp
new file mode 100755
index 0000000..572e222
--- /dev/null
+++ b/libjconer/src/stream.cpp
@@ -0,0 +1,371 @@
+#include "jconer/stream.hpp"
+#include "common/all.hpp"
+#include <fstream>
+using namespace std;
+using namespace COMMON;
+
+namespace JCONER {
+
+IStream::IStream(istream& in)
+    :_fin(in)
+{
+    _lineno = 0;
+    _col = 0;
+    _end = _buff = NULL;
+    _cur_pos = 0;
+
+    _content_length = -1;
+
+    if ((_buff = (char*) malloc(BUFSIZE) ) == NULL) {
+        LOG(FATAL) << "Run out of memory" << std::endl;
+    }
+    _end = _cur = _buff;
+    _readBuffer();
+}
+
+IStream::~IStream() {
+    free(_buff);
+}
+
+int IStream::_readBuffer() {
+    int remaining_length = _getRemainingLength();
+    if (remaining_length == 0) {
+        return EOF;
+    }
+    int length = BUFSIZE > remaining_length ? remaining_length : BUFSIZE;
+    _fin.read(_buff, length);
+    //TODO Error handling
+    _cur = _buff;
+    _end = _buff + length;
+    return 0;
+}
+
+int IStream::_getNChar(char* str, int n) {
+    if (n == 0) return 0;
+
+    int i;
+    int c = 0;
+    for(i = 0; i < n; i ++) {
+        c = _getNextChar();
+        if (c == EOF) {
+            break;
+        }
+        str[i] = (char)c;
+    }
+    return i;
+}
+
+inline int IStream::_getLength() {
+    if (_content_length != -1)
+        return _content_length;
+
+    _cur_pos = _fin.tellg();
+    _fin.seekg(0, ios::end);
+    _content_length = _fin.tellg();
+
+    _fin.seekg(_cur_pos, ios::beg);
+    return _content_length;
+}
+
+inline int IStream::_getRemainingLength() {
+    _cur_pos = _fin.tellg();
+    return _getLength() - _cur_pos;
+}
+
+inline int IStream::_getNextChar() {
+    if (_cur == _end) {
+        int rst = _readBuffer();
+        if (rst == EOF) {
+            return EOF;
+        }
+        //TODO Error handling
+    }
+    return *_cur ++;
+}
+
+inline void IStream::_ungetChar() {
+    if (_cur == _buff) return;
+    _cur --;
+}
+
+bool IStream::_stripWhitespace() {
+    while(true) {
+        int c = _getNextChar();
+        if (isspace(c)) {
+            if (c == '\n') {
+                _lineno ++;
+                _col = 0;
+            } else {
+                _col ++;
+            }
+        } else {
+            if (c == EOF) return true;
+            _ungetChar();
+            return false;
+        }
+    }
+}
+
+Token IStream::getNextToken() {
+    _err.clear();
+    bool iseof = _stripWhitespace();
+    if (iseof) { return Token(TT_END);}
+    int c = _getNextChar();
+    TokenType type;
+
+    type = Token::getTokenOne(c);
+    if (type != TT_INVALID) {
+        Token t(type, _lineno, _col, (char)c);
+        _col ++;
+        return t;
+    }
+
+    if (c == '"') {
+        int esc_count = 0;
+        VarString vs;
+        while(true) { 
+            c = _getNextChar();
+            if (c == '\\') {
+                esc_count ++;
+                int nextc = _getNextChar();
+                switch(nextc) {
+                    case '"':
+                        vs.append('"');
+                        break;
+                    case '\\':
+                        vs.append('\\');
+                        break;
+                    case '/':
+                        vs.append('/');
+                        break;
+                    case 'b':
+                        vs.append('\b');
+                        break;
+                    case 'f':
+                        vs.append('\f');
+                        break;
+                    case 'n':
+                        vs.append('\n');
+                        break;
+                    case 'r':
+                        vs.append('\r');
+                        break;
+                    case 't':
+                        vs.append('\t');
+                        break;
+                    case 'u':
+                        {
+                        esc_count ++;
+                        char tmp[5];
+                        if (_getNChar(tmp, 4) != 4) {
+                            _err.setErrorDetail(_lineno, _col, ET_PARSE_EOF, "Unexpected end of file\n");
+                            goto fail;
+                        }
+                        esc_count += 4;
+                        int32_t value = HexCode::decode(tmp);
+
+                        if (value < 0) {
+                            tmp[4] = '\0';
+                            _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_UNICODE, "Invalid unicode \\u%s\n", tmp) ;
+                            goto fail;
+                        }
+
+                        if (0xD800 <= value && value <= 0xDBFF) {
+                            c = _getNextChar();
+                            nextc = _getNextChar();
+                            if (c == '\\' && nextc == 'u') {
+                                if (_getNChar(tmp, 4) != 4) {
+                                    _err.setErrorDetail(_lineno, _col, ET_PARSE_EOF, "Unexpected end of file\n");
+                                    goto fail;
+                                }
+
+                                int32_t value2 = HexCode::decode(tmp);
+                                if (0xDC00 <= value2 && value2 <= 0xDFFF) {
+                                    value = ((value - 0xD800) << 10) + (value2 - 0xDC00) + 0x10000;
+                                    esc_count += 6;
+                                } else {
+                                    _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_UNICODE, "Invalid unicode \\u%04X\\u%04X\n", value, value2);
+                                    goto fail;
+                                }
+                            } else {
+                                _ungetChar();
+                                _ungetChar();
+                                _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_UNICODE, "Invalid unicode \\u%04X\n", value);
+                                goto fail;
+                            }
+                        } else if (0xDC00 <= value && value <= 0xDFFF) {
+                            _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_UNICODE, "Invalid unicode \\u%04X\n", value);
+                            goto fail;
+                        }
+                        int utf8_size = UTF8::encode(value, tmp, 4);
+                        if (utf8_size < 0) {
+                            _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_UNICODE, "Unicode \\u%04X can't convert to utf8\n", value);
+                            goto fail;
+                        }
+
+                        esc_count -= utf8_size;
+                        vs.append(tmp, utf8_size);
+                        break;
+                        }
+                    default:
+                        _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_CHAR, "Wrong escape char %c\n", (char)c);
+                        goto fail;
+                }
+            }
+            else if (c == '"') {
+                Token t(TT_STRING, _lineno, _col, vs.toString());
+                _col += vs.size() + esc_count + 2/* For " and " */;
+                return t;
+            } else if (c == EOF) {
+                _err.setErrorDetail(_lineno, _col, ET_PARSE_EOF, "Unexpected end of file\n");
+                goto fail;
+            } else {
+                vs.append((char)c);
+            }
+        }
+    }
+
+    if (c == '-' || isdigit(c)) {
+        VarString vs;
+        int nextc = 0;
+
+        if (c == '-') {
+            vs.append(c);
+            c = _getNextChar();
+        }
+
+        vs.append(c);
+        nextc = _getNextChar();
+
+        if (isdigit(nextc)) {
+            if (c == '0') {
+                _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_CHAR, "Number can't start with 0\n");
+                goto fail;
+            }
+            else {
+                vs.append((char)nextc);
+                while(true) {
+                    c = _getNextChar();
+                    if ( isdigit(c) ) {
+                        vs.append((char)c);
+                    } else {
+                        break;
+                    }
+                }
+
+                if (c == '.') {
+frac:
+                    vs.append((char)c); 
+                    nextc = _getNextChar();
+                    if (!isdigit(nextc)) {
+                        _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_CHAR, "Unfinished fraction in number\n");
+                        goto fail;
+                    }
+                    vs.append((char)nextc);
+                    while(true) {
+                        c = _getNextChar();
+                        if (isdigit(c)) {
+                            vs.append((char)c);
+                        } else {
+                            break;
+                        }
+                    }
+
+                    if (c == 'e' || c == 'E') {
+                        goto exp;
+                    } else {
+                        _ungetChar();
+                        Token t(TT_REAL, _lineno, _col, vs.toString()); 
+                        _col += vs.size();
+                        return t;
+                    }
+                } else if (c == 'e' || c == 'E') {
+exp:
+                    vs.append((char)c);
+                    nextc = _getNextChar(); 
+                    if (nextc == '+' || nextc == '-') {
+                        vs.append((char)nextc);
+                        c = _getNextChar();
+                        if (!isdigit(c)) {
+                            _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_CHAR, "Unfinished exp in number\n");
+                            goto fail;
+                        }
+                    } else if (isdigit(nextc)) {
+                        vs.append((char)nextc);
+                    } else {
+                        _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_CHAR, "Unfinished exp in number\n");
+                        goto fail;
+                    }
+                    while(true) {
+                        c = _getNextChar();
+                        if (isdigit(c)) {
+                            vs.append((char)c);
+                        } else {
+                            break;
+                        }
+                    }
+                    _ungetChar();
+                    Token t(TT_REAL, _lineno, _col, vs.toString());
+                    _col += vs.size();
+                    return t;
+                } else {
+                    _ungetChar();
+                    Token t(TT_INTEGER, _lineno, _col, vs.toString());
+                    _col += vs.size();
+                    return t;
+                }
+            }
+        } else if (nextc == '.') {
+            c = nextc;
+            goto frac;
+        } else if (nextc == 'e' || nextc == 'E') {
+            c = nextc;
+            goto exp;
+        } else {
+            _ungetChar();
+            Token t(TT_INTEGER, _lineno, _col, vs.toString());
+            _col += vs.size();
+            return t;
+        }
+
+    }
+
+    if (c == 't' || c == 'f' || c == 'n') { // should be true, false or null
+        VarString vs;
+        vs.append(c);
+        for(int i = 0; i < 3; i ++ ) {
+            c = _getNextChar();
+            if (c == EOF) {
+                _err.setErrorDetail(_lineno, _col, ET_PARSE_EOF, "Unexpected enf of file\n");
+                goto fail;
+            } else {
+                vs.append((char)c);
+            }
+        }
+
+        if (strncmp(vs.toString().c_str(), "true", 4) == 0) {
+            Token t(TT_TRUE, _lineno, _col, vs.toString());
+            _col += vs.size();
+            return t;
+        } else if (strncmp(vs.toString().c_str(), "null", 4) == 0) {
+            Token t(TT_NULL, _lineno, _col, vs.toString());
+            _col += vs.size();
+            return t;
+        } else if (strncmp(vs.toString().c_str(), "false", 4) == 0) {
+            c = _getNextChar();
+            if (c == 'e') {
+                vs.append((char)c);
+                Token t(TT_FALSE, _lineno, _col, vs.toString());
+                _col += vs.size();
+                return t;
+            } else {
+                _err.setErrorDetail(_lineno, _col, ET_PARSE_INVALID_CHAR, "Unknown token\n");
+                goto fail;
+            }
+        }
+    }
+fail:
+    return Token(TT_INVALID, _lineno, _col, "");
+}
+
+}
diff --git a/libjconer/src/token.cpp b/libjconer/src/token.cpp
new file mode 100755
index 0000000..19ed165
--- /dev/null
+++ b/libjconer/src/token.cpp
@@ -0,0 +1,52 @@
+#include "jconer/token.hpp"
+
+namespace JCONER {
+
+static const char* TokenType_Str[] = {
+    "array_open_brace",
+    "array_close_brace",
+    "object_open_brace",
+    "object_close_brace",
+
+    "comma",
+    "colon",
+    "string",
+    "integer",
+    "real",
+
+    "true",
+    "false",
+    "null",
+
+    "end",
+    "invalid",
+    NULL
+};
+
+TokenType Token::getTokenOne(char c) {
+    switch(c) {
+        case '[':
+            return TT_ARRAY_OPEN_BRACE;
+        case ']':
+            return TT_ARRAY_CLOSE_BRACE;
+        case '{':
+            return TT_OBJECT_OPEN_BRACE;
+        case '}':
+            return TT_OBJECT_CLOSE_BRACE;
+        case ',':
+            return TT_COMMA;
+        case ':':
+            return TT_COLON;
+        case EOF:
+            return TT_END;
+        default:
+            return TT_INVALID;
+    }
+}
+
+std::string Token::toString() {
+    std::string rst(TokenType_Str[_type]);
+    return rst + " " + _text;
+}
+ 
+}
diff --git a/libjconer/src/value.cpp b/libjconer/src/value.cpp
new file mode 100755
index 0000000..c2807ce
--- /dev/null
+++ b/libjconer/src/value.cpp
@@ -0,0 +1,398 @@
+#include "jconer/value.hpp"
+#include "jconer/util.hpp"
+#include "common/all.hpp"
+
+using namespace COMMON;
+namespace JCONER {
+
+// JValue definition
+JValue::JValue(ValueType type)
+    :_type(type)
+{
+}
+
+std::string JValue::getString() {
+    return ((JString*)this)->getValue();
+}
+
+long JValue::getInteger() {
+    return ((JInt*)this)->getValue();
+}
+
+bool JValue::getBool() {
+    return _type == VT_TRUE ? true : false;
+}
+
+double JValue::getReal() {
+    return ((JReal*)this)->getValue();
+}
+
+JValue* JValue::get(size_t i) {
+  return ((JArray*)this)->get(i);
+}
+
+JValue* JValue::get(std::string key) {
+  return ((JObject*)this)->get(key);
+}
+
+std::vector<std::string> JValue::getKeys() {
+  return ((JObject*)this)->getKeys();
+}
+
+bool JValue::contain(std::string key) {
+  return ((JObject*)this)->contain(key);
+}
+
+int JValue::size() {
+  if (isObject()) {
+    return ((JObject*)this)->size();
+  } else {
+    return ((JArray*)this)->size();
+  }
+}
+
+JValue::~JValue() {
+}
+
+// JNull definition
+JNull::JNull()
+    :JValue(VT_NULL)
+{
+}
+
+JNull JNull::_instance;
+
+void JNull::printout() {
+    printf("null");
+}
+
+JValue* JNull::deepcopy() {
+    return JNull::getInstance();
+}
+
+// JInt definition
+JInt::JInt(const long value)
+    :JValue(VT_INTEGER), _value(value)
+{
+}
+
+void JInt::printout() {
+    printf("int[%ld]", _value);
+}
+
+JValue* JInt::deepcopy() {
+    return new JInt(_value);
+}
+
+// JReal definition
+JReal::JReal(const double value)
+    :JValue(VT_REAL), _value(value)
+{
+}
+
+void JReal::printout() {
+    printf("real[%f]", _value);
+}
+
+JValue* JReal::deepcopy() {
+    return new JReal(_value);
+}
+
+// JString definition
+JString::JString(const std::string value)
+    :JValue(VT_STRING), _value(value)
+{
+}
+
+JString::JString(const char* str)
+    :JValue(VT_STRING), _value(str)
+{
+}
+
+void JString::printout() {
+    printf("string[%s]", _value.c_str());
+}
+
+std::string JString::getAsciiValue() {
+    VarString vs;
+    int i = 0;
+    char c;
+    const char* p = _value.c_str();
+    int len = _value.size();
+    while (i < len) {
+        c = p[i];
+        switch(c){
+            case '"': vs.append("\\\""); i ++; break;
+            case '/': vs.append("\\/"); i++; break;
+            case '\\': vs.append("\\\\"); i++; break;
+            case '\t': vs.append("\\t"); i++; break;
+            case '\b': vs.append("\\b"); i++; break;
+            case '\f': vs.append("\\f"); i++; break;
+            case '\n': vs.append("\\n"); i++; break;
+            case '\r': vs.append("\\r"); i++; break;
+            default:{
+                if ((unsigned)c <= 0x80) {
+                    vs.append(c);
+                    i ++;
+                } else {
+                    char buffer[13];
+                    int32_t value = 0;
+                    int count = UTF8::decode(p + i, &value);
+                    i += count;
+                    if (value < 0x10000){
+                       sprintf(buffer, "\\u%04X", value); 
+                       vs.append(buffer, 6);
+                    } else {
+                        int32_t first, second;
+                        value -= 0x10000;
+                        first = 0xD800 | ((value & 0xFFC00) >> 10);
+                        second = 0xDC00 | (value & 0x003FF);
+
+                        sprintf(buffer, "\\u%04X\\u%04X", first, second);
+                        vs.append(buffer, 12);
+                    }
+                }
+            }
+        }
+    }
+    return vs.toString();
+}
+
+JValue* JString::deepcopy() {
+    return new JString(_value);
+}
+
+// JTrue definition
+JTrue::JTrue()
+    :JValue(VT_TRUE)
+{
+}
+
+JTrue JTrue::_instance;
+
+void JTrue::printout() {
+    printf("true");
+}
+
+JValue* JTrue::deepcopy()  {
+    return JTrue::getInstance();
+}
+
+// JFalse definition
+JFalse::JFalse()
+    :JValue(VT_FALSE)
+{
+}
+
+JFalse JFalse::_instance;
+
+void JFalse::printout() {
+    printf("false");
+}
+
+JValue* JFalse::deepcopy()  {
+    return JFalse::getInstance();
+}
+
+// JArray definition
+JArray::JArray()
+    :JValue(VT_ARRAY)
+{
+}
+
+JArray::JArray(const std::vector<JValue*>& array)
+    :JValue(VT_ARRAY), _array(array)
+{
+}
+
+InsertError JArray::append(JValue* element) {
+    if (element == this) return IE_SELF;
+    if (element == NULL) return IE_NULL;
+    _array.push_back(element);
+    return IE_SUC;
+}
+
+void JArray::append(const long value) {
+    JValue* elt = new JInt(value);
+    _array.push_back(elt);
+}
+
+void JArray::append(const int value) {
+    JValue* elt = new JInt(value);
+    _array.push_back(elt);
+}
+
+void JArray::append(const size_t value) {
+    JValue* elt = new JInt(value);
+    _array.push_back(elt);
+}
+
+void JArray::append(const std::string value) {
+    JValue* elt = new JString(value);
+    _array.push_back(elt);
+}
+
+void JArray::append(const char* str) {
+    _array.push_back(new JString(str));
+}
+
+void JArray::append(const double value) {
+    JValue* elt = new JReal(value);
+    _array.push_back(elt);
+}
+void JArray::append(const bool value) {
+    JValue* elt = NULL;
+    if (value) {
+        elt = JTrue::getInstance();
+    } else {
+        elt = JFalse::getInstance();
+    }
+    _array.push_back(elt);
+}
+
+void JArray::appendNull() {
+    JValue* elt = JNull::getInstance();
+    _array.push_back(elt);
+}
+
+void JArray::printout() {
+    printf("[");
+    for(size_t i = 0; i < _array.size(); i ++) {
+        _array[i]->printout();
+        if (i != _array.size() - 1)
+            printf(",");
+    }
+    printf("]");
+}
+
+JArray::~JArray() {
+    for(size_t i = 0; i < _array.size(); i ++ ) {
+        if (_array[i]->isFalse() || _array[i]->isTrue() || _array[i]->isNull()) continue;
+        delete _array[i];
+    }
+}
+
+JValue* JArray::pop(size_t i) {
+    if (i < _array.size()) {
+        JValue* rst = _array[i];
+        _array.erase(_array.begin() + i);
+        return rst;
+    }
+    return NULL;
+}
+JValue* JArray::pop_back() {
+    JValue* rst = _array.back();
+    _array.pop_back();
+    return rst;
+}
+
+JValue* JArray::deepcopy() {
+    JArray* rst = new JArray();
+    for(size_t i = 0; i < _array.size(); i ++ ) {
+        rst->append(_array[i]->deepcopy());
+    }
+    return rst;
+}
+
+// JObject definition
+JObject::JObject()
+    :JValue(VT_OBJECT)
+{
+}
+
+JObject::JObject(const std::map<std::string, JValue*>& object)
+    :JValue(VT_OBJECT)
+{
+    _object.insert(object.begin(), object.end());
+}
+
+std::vector<std::string> JObject::getKeys() {
+    std::vector<std::string> keys;
+    for(std::map<std::string, JValue*>::iterator iter = _object.begin();
+            iter != _object.end(); iter ++ ) {
+        keys.push_back(iter->first);
+    }
+    return keys;
+}
+
+InsertError JObject::put(const std::string key, JValue* value) {
+    if (value == this) return IE_SELF;
+    if (value == NULL) return IE_NULL;
+    _object[key] = value;
+    return IE_SUC;
+}
+
+void JObject::put(const std::string key, const long value) {
+    _object[key] = new JInt(value);
+}
+
+void JObject::put(const std::string key, const size_t value) {
+    _object[key] = new JInt(value);
+}
+
+void JObject::put(const std::string key, const int value) {
+    _object[key] = new JInt(value);
+}
+
+void JObject::put(const std::string key, const std::string value) {
+    _object[key] = new JString(value);
+}
+
+void JObject::put(const std::string key, const char* str) {
+    _object[key] = new JString(str);
+}
+
+void JObject::put(const std::string key, const double value) {
+    _object[key] = new JReal(value);
+}
+
+void JObject::put(const std::string key, const bool value)  {
+    if (value) {
+        _object[key] = JTrue::getInstance();
+    } else {
+        _object[key] = JFalse::getInstance();
+    }
+}
+
+void JObject::put(const std::string key) {
+    _object[key] = JNull::getInstance();
+}
+
+void JObject::printout() {
+    printf("{");
+    for(std::map<std::string, JValue*>::iterator iter = _object.begin();
+            iter != _object.end(); iter ++) {
+        printf("%s:", iter->first.c_str());
+        iter->second->printout();
+        printf(",");
+    }
+    printf("}");
+}
+
+JObject::~JObject() {
+    for(std::map<std::string, JValue*>::iterator iter = _object.begin();
+            iter != _object.end(); iter ++) {
+        if (iter->second->isFalse() || iter->second->isTrue() || iter->second->isNull()) continue;
+        delete iter->second;
+    }
+}
+
+JValue* JObject::pop(std::string key) {
+    if (contain(key)) {
+        JValue* rst = _object[key];
+        _object.erase(key);
+        return rst;
+    }
+    return NULL;
+}
+
+JValue* JObject::deepcopy() {
+    JObject* rst = new JObject();
+    for(std::map<std::string, JValue*>::iterator iter = _object.begin();
+            iter != _object.end(); iter ++) {
+        rst->put(iter->first, iter->second->deepcopy());
+    }
+    return rst;
+}
+
+}
diff --git a/libjconer/test/test_deepcopy.cpp b/libjconer/test/test_deepcopy.cpp
new file mode 100755
index 0000000..5f4e32c
--- /dev/null
+++ b/libjconer/test/test_deepcopy.cpp
@@ -0,0 +1,15 @@
+#include "jconer/json.hpp"
+#include <iostream>
+
+using namespace JCONER;
+
+int main(int argc, char** argv) {
+    PError err;
+    JValue* rst = load(argv[1], err);
+    if (rst != NULL) {
+        JValue* copy = rst->deepcopy();
+        dump(copy, std::cout);
+        delete copy;
+        delete rst;
+    }
+}
diff --git a/libjconer/test/test_dump.cpp b/libjconer/test/test_dump.cpp
new file mode 100755
index 0000000..17739f0
--- /dev/null
+++ b/libjconer/test/test_dump.cpp
@@ -0,0 +1,33 @@
+#include <iostream>
+#include "jconer/json.hpp"
+
+using namespace JCONER;
+
+int main(int argc, char** argv) {
+    JArray* arr_value = new JArray();
+    arr_value->append(128);
+    arr_value->append(12.8);
+    arr_value->append("Allenbo\tLin");
+
+    JObject* obj_value = new JObject();
+    obj_value->put("name", "杩");
+    obj_value->put("age", 23);
+
+    arr_value->append(obj_value);
+    
+    arr_value->printout();
+    dumpFile(arr_value, "myjson", DUMP_COMPACT_PRINT);
+    char* str = NULL;
+    dumps(arr_value, &str);
+    std::cout << str << std::endl;
+    free(str);
+    delete arr_value;
+    //JValue* value = load(argv[1]);
+    //char* str = NULL;
+    //dumpFile(value, "myjson");
+    //dumps(value, &str);
+    //std::cout << str << std::endl;
+    //free(str);
+    //delete value;
+}
+
diff --git a/libjconer/test/test_load.cpp b/libjconer/test/test_load.cpp
new file mode 100755
index 0000000..27867ad
--- /dev/null
+++ b/libjconer/test/test_load.cpp
@@ -0,0 +1,16 @@
+#include "jconer/json.hpp"
+using namespace JCONER;
+
+int main(int argc, char** argv) {
+    PError err;
+    //JValue *rst = loads("\"\\u6797\"", err);
+    JValue* rst = load(argv[1], err);
+    if (rst != NULL) {
+        //rst->printout();
+        //printf("\n");
+        dumpFile(rst, "myjson", DUMP_PRETTY_PRINT | DUMP_SORT_KEY);
+        delete rst;
+    } else {
+        printf("%s", err.text.c_str()); 
+    }
+}
diff --git a/libjconer/test/test_parser.cpp b/libjconer/test/test_parser.cpp
new file mode 100755
index 0000000..c65f44e
--- /dev/null
+++ b/libjconer/test/test_parser.cpp
@@ -0,0 +1,23 @@
+#include "jconer/json.hpp"
+using namespace JCONER;
+
+int main(int argc, char** argv) {
+    //FileIStream fin(argv[1]);
+    //Parser parser(fin);
+    Parser parser;
+
+    JValue *rst = parser.parseFromFile(argv[1]);
+    if (rst->type() == VT_ARRAY) {
+        JArray* arr_value = (JArray*) rst;
+        arr_value->append(128);
+        arr_value->append(12.8);
+        arr_value->append("allenbo");
+        JObject* obj_value = new JObject();
+        obj_value->put("name", "allenbo");
+        obj_value->put("age", 23);
+        arr_value->append(obj_value);
+    }
+    rst->printout();
+    printf("\n");
+    delete rst;
+}
diff --git a/libjconer/test/test_serializer.cpp b/libjconer/test/test_serializer.cpp
new file mode 100755
index 0000000..a7dfc11
--- /dev/null
+++ b/libjconer/test/test_serializer.cpp
@@ -0,0 +1,253 @@
+#include "jconer/json.hpp"
+#include <iostream>
+#include <vector>
+#include <map>
+#include <cassert>
+
+using namespace JCONER;
+
+class Simple {
+    public:
+        Simple() : int_value(0), string_value("") { }
+        Simple(int i, std::string s): int_value(i), string_value(s) {}
+        Simple(const Simple& s): int_value(s.int_value), string_value(s.string_value) {}
+
+        template<class Serializer>
+            void serialize(Serializer& serializer) {
+                serializer & int_value;      
+                serializer & string_value;
+            }
+        friend std::ostream& operator<<(std::ostream& out, const Simple& s) {
+            out << s.int_value << " " << s.string_value;
+            return out;
+        }
+        friend bool operator==(const Simple& lhs, const Simple& rhs);
+    private:
+        int int_value;
+        std::string string_value;
+};
+
+bool operator==(const Simple& lhs, const Simple& rhs) {
+    return lhs.int_value == rhs.int_value && lhs.string_value == rhs.string_value;
+}
+
+bool operator!=(const Simple& lhs, const Simple& rhs) {
+    return !(lhs == rhs);
+}
+
+
+class Complex {
+    public:
+        Complex():int_value(0), string_value("") {
+            vector_float_value.clear();
+        }
+
+        Complex(int i, std::string s): int_value(i), string_value(s) {
+            for(int i = 0; i < 10; i ++ ) {
+                vector_float_value.push_back(i * 1.2);
+            }
+        }
+
+        template<class Serializer>
+            void serialize(Serializer& serializer) {
+                serializer & int_value;
+                serializer & string_value;
+                serializer & vector_float_value;
+            }
+        friend std::ostream& operator<<(std::ostream& out, const Complex& c) {
+            out << c.int_value << " " << c.string_value << " [ ";
+            for(int i = 0; i < 10; i ++ ) {
+                out << c.vector_float_value[i];
+                if (i != 10 - 1) {
+                    out << " ,";
+                }
+            }
+            out << " ]";
+            return out;
+        }
+        friend bool operator==(const Complex& lhs, const Complex& rhs);
+    private:
+        int int_value;
+        std::string string_value;
+        std::vector<float> vector_float_value;
+};
+
+bool operator==(const Complex& lhs, const Complex& rhs) {
+    if (lhs.int_value != rhs.int_value) return false;
+    if (lhs.string_value != rhs.string_value) return false;
+    if (lhs.vector_float_value.size() != rhs.vector_float_value.size()) return false;
+    for(int i = 0; i < lhs.vector_float_value.size(); i ++) {
+        if (lhs.vector_float_value[i] != rhs.vector_float_value[i]) return false;
+    }
+    return true;
+}
+
+bool operator!=(const Complex& lhs, const Complex& rhs) {
+    return !(lhs == rhs);
+}
+
+void test_primitives() {
+    // out serializer
+    OutSerializer sout;
+    sout & 4;
+    sout & 1.1f;
+    sout & "string";
+    JValue* content = sout.getContent();
+    dump(content, std::cout, DUMP_ENSURE_ASCII);
+    std::cout << std::endl << "Suppose to print out [" << 4 << ", " <<  1.1f << ", string ]" << std::endl;
+
+    // in serializer
+    InSerializer sin(content);
+    int i;
+    float f;
+    std::string s;
+
+    sin & i;
+    sin & f;
+    sin & s;
+
+    assert (i == 4 && f == 1.1f && s == "string");
+    delete content;
+
+}
+
+void test_vector_primitive() {
+    // out serializer 
+    OutSerializer sout;
+    std::vector<int> int_vec(10);
+    for(int i = 0; i < 10; i ++ ) {
+        int_vec[i] = i;
+    }
+
+    sout & int_vec;
+    JValue* content = sout.getContent();
+    dump(content, std::cout, DUMP_ENSURE_ASCII);
+
+    std::cout << std::endl << "Suppose to print out [ [";
+    for(int i = 0; i < 10; i ++ ) {
+        std::cout << i;
+        if (i != 10 - 1) {
+            std::cout << ", ";
+        }
+    }
+    std::cout << "] ]" << std::endl;
+
+    // in serializer
+    InSerializer sin(content);
+    std::vector<int> another_int_vec;
+
+    sin & another_int_vec;
+    assert (another_int_vec.size() == 10);
+    for(int i = 0; i < 10; i ++ ) {
+        assert(another_int_vec[i] == i);
+    }
+    delete content;
+}
+
+void  test_pair() {
+    // out serializer
+    OutSerializer sout;
+    std::pair<int, double> p = std::make_pair(20, 10.2);
+
+    sout & p;
+    JValue* content = sout.getContent();
+    dump(content, std::cout, DUMP_ENSURE_ASCII);
+
+    std::cout << std::endl << "Suppose to print out [ [";
+    std::cout << "20 , 10.2 ] ]" << std::endl;
+
+    // in serializer
+    InSerializer sin(content);
+    std::pair<int, double> anp;
+    sin & anp;
+    assert(anp.first == p.first && anp.second == p.second);
+    delete content;
+}
+
+void test_map() {
+    // out serializer
+    OutSerializer sout;
+    std::map<int, std::string> m;
+    for(int i = 0; i < 10; i ++) {
+        m[i] = "value";
+    }
+
+    sout & m;
+    JValue* content = sout.getContent();
+    dump(content, std::cout, DUMP_ENSURE_ASCII);
+
+    std::cout << std::endl << "Suppose to print out [ [";
+    for(int i = 0; i < 10; i ++ ) {
+        std::cout << "[ " << i << ", value ]";
+        if (i != 9 ) {
+            std::cout << ", ";
+        }
+    }
+    std::cout << "] ]" << std::endl;
+
+    // in seralizer
+    InSerializer sin(content);
+    std::map<int, std::string> anm;
+    sin & anm;
+
+    assert(anm.size() == 10);
+    for(int i = 0; i < 10; i ++) {
+        assert(anm.count(i) == 1);
+        assert(anm[i] == "value");
+    }
+    delete content;
+}
+
+void test_simple() {
+    // out serializer 
+    OutSerializer sout;
+    Simple s(10, "John");
+
+    sout & s;
+    JValue* content = sout.getContent();
+    dump(content, std::cout, DUMP_ENSURE_ASCII);
+
+    std::cout << std::endl << "Suppose to print out [ [";
+    std::cout << s << " ] ]" << std::endl;
+
+    // in serializer
+    InSerializer sin(content);
+    Simple ans;
+    sin & ans;
+
+    assert(ans == s);
+    delete content;
+}
+
+void test_complex() {
+    // out serializer
+    OutSerializer sout;
+    Complex c(10, "John");
+
+    sout & c;
+    JValue* content = sout.getContent();
+    dump(content, std::cout, DUMP_ENSURE_ASCII);
+
+    std::cout << std::endl << "Suppose to print out [ [";
+    std::cout << c << " ] ]" << std::endl;
+
+    // in serializer
+    InSerializer sin(content);
+    Complex anc;
+
+    sin & anc;
+
+    assert(anc == c);
+    delete content;
+}
+
+int main() {
+    test_primitives();
+    test_vector_primitive();
+
+    test_pair();
+    test_map();
+
+    test_simple();
+    test_complex();
+}
diff --git a/libjconer/test/test_stream.cpp b/libjconer/test/test_stream.cpp
new file mode 100755
index 0000000..e0c42ba
--- /dev/null
+++ b/libjconer/test/test_stream.cpp
@@ -0,0 +1,13 @@
+#include "jconer/json.hpp"
+#include <iostream>
+using namespace JCONER;
+using namespace std;
+
+int main(int argc, char** argv) {
+    ifstream in(argv[1]);
+    IStream stream(in);
+    while(true) {
+        Token t = stream.getNextToken();
+        if (t.type() == TT_END) break;
+    }
+}
diff --git a/sample/about/about_get.cpp b/sample/about/about_get.cpp
old mode 100644
new mode 100755
diff --git a/sample/changes/change_get.cpp b/sample/changes/change_get.cpp
old mode 100644
new mode 100755
diff --git a/sample/changes/change_list.cpp b/sample/changes/change_list.cpp
old mode 100644
new mode 100755
diff --git a/sample/children/child_delete.cpp b/sample/children/child_delete.cpp
old mode 100644
new mode 100755
diff --git a/sample/children/child_insert.cpp b/sample/children/child_insert.cpp
old mode 100644
new mode 100755
diff --git a/sample/children/child_list.cpp b/sample/children/child_list.cpp
old mode 100644
new mode 100755
diff --git a/sample/files/file_delete.cpp b/sample/files/file_delete.cpp
old mode 100644
new mode 100755
diff --git a/sample/files/file_get.cpp b/sample/files/file_get.cpp
old mode 100644
new mode 100755
diff --git a/sample/files/file_insert.cpp b/sample/files/file_insert.cpp
old mode 100644
new mode 100755
diff --git a/sample/files/file_list.cpp b/sample/files/file_list.cpp
old mode 100644
new mode 100755
diff --git a/src/about.cpp b/src/about.cpp
old mode 100644
new mode 100755
diff --git a/src/apps.cpp b/src/apps.cpp
old mode 100644
new mode 100755
diff --git a/src/changes.cpp b/src/changes.cpp
old mode 100644
new mode 100755
diff --git a/src/children.cpp b/src/children.cpp
old mode 100644
new mode 100755
diff --git a/src/comments.cpp b/src/comments.cpp
old mode 100644
new mode 100755
diff --git a/src/credential.cpp b/src/credential.cpp
index 7f0ba0d..820d2ab 100644
--- a/src/credential.cpp
+++ b/src/credential.cpp
@@ -38,17 +38,50 @@ void Credential::refresh(std::string at, std::string rt, long te, std::string it
     dump();
 }
 
+Credential::Credential(std::map<std::string, std::string> *auth) : authMap(auth){
+#ifdef GDRIVE_DEBUG
+    CLASS_INIT_LOGGER("Credential", L_DEBUG);
+#endif
+ if ((*auth)["refresh_token"] == "") {
+        _invalid = true;
+        _access_token = "";
+        _client_id = (*auth)["client_id"];
+        _client_secret = (*auth)["client_secret"];
+        _refresh_token = "";
+        _id_token = "";
+    } else {
+        _invalid = false;
+        _access_token = (*auth)["access_token"];
+        _client_id = (*auth)["client_id"];
+        _client_secret = (*auth)["client_secret"];
+        _refresh_token = (*auth)["refresh_token"];
+        _id_token = (*auth)["id_token"];
+    }
+    _token_expiry = 0;
+    _store = NULL;
+}
+
+
 void Credential::dump() {
     if (_store == NULL) {
-        CLOG_WARN("This is no store to save tokens\n");
-        return;
+        (*authMap)["access_token"]  = _access_token;
+        (*authMap)["client_id"]     = _client_id;
+        (*authMap)["client_secret"] = _client_secret;
+        (*authMap)["refresh_token"] = _refresh_token;
+        (*authMap)["id_token"]      = _id_token;
+    } else {
+	if (!_access_token.empty())
+            _store->put("access_token", _access_token);
+	if (!_client_id.empty())
+            _store->put("client_id", _client_id);
+	if (!_client_secret.empty())
+            _store->put("client_secret", _client_secret);
+	if (!_refresh_token.empty())
+            _store->put("refresh_token", _refresh_token);
+	if (!_id_token.empty())
+            _store->put("id_token", _id_token);
+        //_store->dump();	    
     }
-    _store->put("access_token", _access_token);
-    _store->put("client_id", _client_id);
-    _store->put("client_secret", _client_secret);
-    _store->put("refresh_token", _refresh_token);
-    _store->put("id_token", _id_token);
-    _store->dump(); 
 }
 
 CredentialHttpRequest::CredentialHttpRequest(Credential* cred, std::string uri, RequestMethod method)
diff --git a/src/drive.cpp b/src/drive.cpp
old mode 100644
new mode 100755
diff --git a/src/filecontent.cpp b/src/filecontent.cpp
old mode 100644
new mode 100755
diff --git a/src/files.cpp b/src/files.cpp
old mode 100644
new mode 100755
diff --git a/src/gitem.cpp b/src/gitem.cpp
old mode 100644
new mode 100755
diff --git a/src/oauth.cpp b/src/oauth.cpp
old mode 100644
new mode 100755
diff --git a/src/parents.cpp b/src/parents.cpp
old mode 100644
new mode 100755
diff --git a/src/permissions.cpp b/src/permissions.cpp
old mode 100644
new mode 100755
diff --git a/src/replies.cpp b/src/replies.cpp
old mode 100644
new mode 100755
diff --git a/src/request.cpp b/src/request.cpp
old mode 100644
new mode 100755
diff --git a/src/revisions.cpp b/src/revisions.cpp
old mode 100644
new mode 100755
diff --git a/src/servicerequest.cpp b/src/servicerequest.cpp
old mode 100644
new mode 100755
diff --git a/src/store.cpp b/src/store.cpp
old mode 100644
new mode 100755
diff --git a/test/test_about.cpp b/test/test_about.cpp
old mode 100644
new mode 100755
diff --git a/test/test_change.cpp b/test/test_change.cpp
old mode 100644
new mode 100755
diff --git a/test/test_children.cpp b/test/test_children.cpp
old mode 100644
new mode 100755
diff --git a/test/test_file.cpp b/test/test_file.cpp
old mode 100644
new mode 100755
diff --git a/test/test_filestore.cpp b/test/test_filestore.cpp
old mode 100644
new mode 100755
diff --git a/test/test_oauth.cpp b/test/test_oauth.cpp
old mode 100644
new mode 100755
diff --git a/test/test_request.cpp b/test/test_request.cpp
old mode 100644
new mode 100755
-- 
2.17.1

